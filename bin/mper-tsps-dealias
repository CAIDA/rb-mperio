#!/usr/bin/env ruby

#################################################################################
## Implements the IP Prespecified Timestamp dealias method described in
## "Resolving IP Aliases with Prespecified Timestamps", Sherry et al., IMC'10
##
## There is one line of output for each pair of candidate addresses (IPa,IPb), 
## as follows:
## <candidate_pair>|<suitability_check>|<alias_validity_check|<reverse_path>
##   <alias_check>|<shared_clk>|<distance_loop>|<overall>
##
## The structure and possible values in each section are listed below:
##
## <candidate_pair> MANDATORY
##   IPa,IPb
##   e.g. 192.168.1.1,192.168.1.2
##
## <suitability_check> MANDATORY
##   <result>,<result>
##   The suitability check is performed on each address.
##   
##   The possible result values are:
##     P4Sx => Pass, 4 Stamps
##     P3Sx => Pass, 3 Stamps
##     P2Sx => Pass, 2 Stamps
##     F1Sx => Fail, One Stamp
##     FNSx => Fail, No Stamp
##     FNRx => Fail, No Reply
##     FESx => Fail, Extra Stamp
##     FVSx => Fail, Varying Stamps (multiple stamping behaviours were oberved)
##      (where x is the number of probes that were replied to)
## 
## <alias_validity_check> OPTIONAL
##   <result>,<result>
##   The alias validity check is only performed if both IPa and IPb pass the 
##   suitability check.
##
##   Possible values are:
##     P2S => Pass, Two Stamps
##     P3S => Pass, Three Stamps (weeded out in alias check)
##     P4S => Pass, Four Stamps
##     FNR => Fail, No Reply 
##     F1S => Fail, One Stamp
##     FNS => Fail, No Stamps
##     FVS => Fail, Varying Stamps (multiple stamping behaviours were oberved)
##     FRP => Fail, Reverse Path (a 4 stamper elicited 2 or 3 stamps) (NOALIAS)
##
## <reverse_path> OPTIONAL
##   The reverse path check is only performed if 
##   (IPa==P2S && IPb==F1S) || (IPa==F1S && IPb==P2S)
##   Works by probing the P2S interface (A) with (A|BABA) to determine if B
##   is in fact in the return path from A.
##
##   Possible values are:
##     FNR => Fail, No Reply
##     FVS => Fail, Varying Stamps
##     FNS => Not enough data to make a conclusion (UNKNOWN-NOALIAS)
##     F1S => Should not happen (load balancing?) (ERROR)
##     F2S => A is in the fwd path, but not reverse? (UNKNOWN-NOALIAS)
##     F3S => A is in both fwd and reverse path (NOALIAS)
##     F4S => Should not happen (ERROR)
##
## <alias_check> OPTIONAL
##   The alias check is only performed if both IPa and IPb pass the 
##   validity check
##
##   Possible values are:
##     P2S => Pass, Two Stamps
##     P4S => Pass, Four Stamps (indicates an alias)
##     F3S => Fail, Three Stamps (an error condition)
##     FIR => Fail, Insufficient Stamps (50% total replies are required)
##
## <shared_clk> OPTIONAL
##   The shared clock test is only performed if the alias check test is
##   passed with the PTS flag, indicating that the replies were stamped
##   twice.
##
##   Possible values are:
##     PSC  => Pass, Shared Clock
##     PME  => Pass, Midnight/Epoch
##     FDT  => Fail, Decreasing Timestamp
##     F90  => Fail, less than 90% stamp consistency
##
## <distance_loop> OPTIONAL
##   The distance/loop test is only preformed if the shared clock test is
##   passed with the PSC flag.
##
##   Possible values are:
##     PDI  => Pass, Distance
##     FNRx => Fail, No Reply (where x is the number of noreplies)
##     FTV  => Fail, TTL Variance (within the probes to a single interface)
##
## <overall> MANDATORY
##   The overall value is the end result of performing the dealias algorithm
##   on the candidate pair.
## 
##   Possible values are:
##     ALIAS            => Confirmed as aliases.
##     NOALIAS          => Confirmed to not be aliases.
##     UNKNOWN          => A determination could not be made.
##     UNKNOWN-REPROBE  => Could potentially be resolved by reprobing.
##     UNKNOWN-ALIAS    => Are probably aliases but cannot be confirmed.
##     UNKNOWN-NOALIAS  => Are probably not aliases but cannot be confirmed
##     INELIGIBLE => The candidate interfaces were not suitable for this
##                   technique.
##     ERROR      => An unexpected result not handled by the algorithm.
##
#############################################################################

if $0 =~ /dev$/
  $: << "#{ENV['HOME']}/caida/rb-mperio/ext"
  $: << "#{ENV['HOME']}/caida/rb-mperio/lib"
else
  require 'rubygems'
end

require 'ostruct'
require 'optparse'

require 'mperio'

#never buffer stdout
$stdout.sync = true

$options = OpenStruct.new
$options.spacing = 0
$options.log_path = nil  # disable logging by default

REPEAT = 5

opts = OptionParser.new

opts.banner="usage: #{$0} [-?fv] [-n concurrency] [-s spacing] [-l logfile]\n"\
 + " " * $0.to_s.length + "        -p mperport -c candidatefile | IPa IPb"

opts.on("-p", "--mper-port=NUM", Integer,
	"mper control socket port (REQUIRED)") do |v|
  $options.mper_port = v
end

opts.on("-c", "--candidates=PATH",
        "file with candidate pair information") do |v|
  $options.candidate_path = v
end

opts.on("-n", "--concurrency=NUM", Integer,
        "max pairs to dealias concurrently (default: unlimited)") do |v|
  $options.concurrency = v
end

opts.on("-s", "--spacing=NUM", Integer,
        "spacing (sec) between probes (default: #{$options.spacing})") do |v|
  $options.spacing = v
end

opts.on("-f", "--full", TrueClass, "show full result output") do |v|
  $options.full = v
end

opts.on("-v", "--[no-]verbose", TrueClass,  "show detailed progress") do |v|
  $options.verbose = v
end

opts.on("-l", "--log=PATH", "mper command/result message log path") do |v|
  $options.log_path = v
end

opts.on_tail("-?", "--help", "show this message") do
  puts opts
  exit
end

begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!.to_s + "\n\n"
  $stderr.puts opts
  exit 1
end

unless $options.mper_port
  $stderr.puts "ERROR: missing mper port\n\n"
  $stderr.puts opts
  exit -1
end

unless $options.candidate_path || ARGV.length >= 1
  $stderr.puts "ERROR: candidate file path "\
    "or both IPa and IPb must be specified\n\n"
  $stderr.puts opts
  exit -1
end

#============================================================================

class CandidateFile

  attr_reader :current_candidate

  def initialize(candidate_path)
    @candidate_path = candidate_path
    @candidate_io = File.open candidate_path
    @done = false
    advance
  end

  def advance
    if @done
      @current_candidate = nil
    else
      loop do
        line = @candidate_io.gets
        if line
          next if line =~ /^\#/ || line =~ /^\s*$/
          line.chomp!
          if line =~ /,/
            candidates = line.split(/,/)
          else
            candidates = line.split(/ /)
          end
          @current_candidate = candidates
          break
        else
          @done = true
          @current_candidate = nil
          break
        end
      end
    end
    return @current_candidate
  end

end

class ImmediateCandidates

  def initialize(candidates)
    @candidates = candidates
    # @ipa = validate_ip(ipa)
    # @ipb = validate_ip(ipb)
    advance
  end
  
  def validate_ip(ip)
    if ip =~ /^\d+\.\d+\.\d+\.\d+$/
      ip
    else
      $stderr.puts "ERROR: malformed candidate ip: \"#{ip}\""
      advance
    end
  end
  
  def current_candidate
    @current_candidate
  end
  
  def advance
    candidate = @candidates.shift
    if !candidate
      @current_candidate = nil
    elsif candidate =~ /,/
      @current_candidate = candidate.split(/,/)
    else
      @current_candidate = [candidate, @candidates.shift]
    end
    @current_candidate
  end
end


#============================================================================

class Probe
  attr_accessor :id, :task, :dest, :tsps_ips, :result
  
  def initialize(dest, tsps_ips)
    self.dest = dest
    self.tsps_ips = tsps_ips
  end

  def to_s
    "Probe #{id}: (#{dest}|#{tsps_ips.join(',')})"
  end
    
end

#============================================================================
class TspsDealiasManager
  
  def initialize

    # the list of tasks (must implement next_probe, receive_probe and taskid)
    @pending_tasks = []
    @next_task_id = 1
    
    @pending_probes = {}
    @next_probe_id = 0
    
    # initialize the list of candidates to probe
    if $options.candidate_path
      @candidates = CandidateFile.new $options.candidate_path
    else
      @candidates = ImmediateCandidates.new ARGV
    end
    
    # initialize the mper connection
    begin
      @mperio = MperIO.new $options.mper_port, $options.log_path
      @mperio.delegate = self
    rescue
      $stderr.puts "Failed to connect to mper on port " +
        "#{$options.mper_port}. Is mper running?"
      exit -1
    end
    
  end
  
  def start
    @mperio.start
  end
  
  def stop
    @mperio.stop
  end
  
  def get_next_task_id
    id = @next_task_id
    @next_task_id += 1
    return id
  end
  
  def get_next_probe_id
    id = @next_probe_id
    @next_probe_id += 1
    return id
  end
  
  ####
  # used by the TspsDealiasTask objects to queue a probe that they want sent
  #
  def queue_probe(task, probe)
    probe.id = get_next_probe_id()
    probe.task = task
    tsps_ips_s = (probe.tsps_ips) ? probe.tsps_ips.join(',') : ""
    # if $options.verbose
    #  printf "probing (%s|%s) @ %d\n", probe.dest, tsps_ips_s, probe.id 
    # end
    @pending_probes[probe.id] = probe
    @mperio.ping_icmp probe.id, probe.dest, $options.spacing, probe.tsps_ips
  end
  
  ####
  # used by this object to find the probe object for the given reply
  def match_result(result)
    probe = @pending_probes.delete result.reqnum
    return probe
  end
  
  def fill_task_queue
    while (candidates = @candidates.current_candidate) != nil
      if $options.concurrency && @pending_tasks.length >= $options.concurrency
        @reached_concurrency = true
        break
      end
      task = TspsDealiasTask.new(get_next_task_id(), candidates)
      @pending_tasks.push task
      @candidates.advance
    end
  end
  
  def mperio_on_more
    # puts "more" if $options.verbose
    @more = false
    
    # fill the task list
    fill_task_queue()
    
    probe_next_task()

    if @pending_tasks.length == 0 && @pending_probes.length == 0
      stop()
    end
  end

  def probe_next_task
    task_cnt = @pending_tasks.length

    task_cnt.times do |i|
      task = @pending_tasks[i]
      unless task
        break
      end

      #remove the task from the 'head' of the list
      @pending_tasks.delete task
      
      # no need to continue probing it
      if task.is_complete
        fill_task_queue()
        probe_next_task()
      else
        #append it to the 'tail' of the list
        @pending_tasks.push task
        
        # ask for the next probe it wants to send
        probe =  task.next_probe
        if probe
          queue_probe(task, probe)
        else
          @more = true
          break
        end
      end
    end
  end
  
  def mperio_on_data(result)
    #printf "mperio_on_data: %p\n", result if $options.verbose

    probe = match_result(result)

    if probe
      probe.result = result
      probe.task.receive_probe(probe)
    else
      $stderr.puts "ignoring duplicate reply received from " +
        "#{result.probe_dest} for probe #{result.reqnum}"
      # exit -1
    end

    fill_task_queue()

    if @more
      mperio_on_more()
    end
  end


  def mperio_on_error(reqnum, message)
    $stderr.printf "mperio_on_error: reqnum=%d msg=%s\n", reqnum, message
    @mperio.stop
    exit 1
  end


  def mperio_on_send_error(reqnum, message)
    $stderr.printf "mperio_on_send_error: reqnum=%d msg=%s\n", reqnum, message
    @pending_tasks.remove reqnum
    @mperio.suspend if @pending_tasks.length == 0 && @queued_tasks.length == 0
  end


  def mperio_service_failure(message)
    $stderr.printf "mperio_service_failure: %s\n", message
    @mperio.stop
    exit 1
  end

end

class DealiasResult
  
  attr_reader :ipa, :ipb
  attr_accessor :suit_check, :alias_validity_check, :ret_path, :alias_check
  attr_accessor :shared_clk, :distance_loop, :overall
  attr_accessor :verbose
  
  def initialize(ipa, ipb)
    @ipa = ipa
    @ipb = ipb
    @suit_check = []
    @alias_validity_check = []
    @ret_path = "-"
    @alias_check = "-"
    @shared_clk = "-"
    @distance_loop = "-"
    @verbose = []
  end
  
  def to_s
    dump_verbose() if $options.verbose
    @alias_validity_check[0] = "-" unless @alias_validity_check[0]
    @alias_validity_check[1] = "-" unless @alias_validity_check[1]
    result = sprintf("%s,%s|%s,%s|%s,%s|%s|%s|%s|%s|%s", 
                     @ipa, @ipb, @suit_check[0], @suit_check[1],
                     @alias_validity_check[0], @alias_validity_check[1],
                     @ret_path, @alias_check, @shared_clk, @distance_loop,
                     @overall)
  end  

  def dump_verbose
    @verbose.each do |line|
      puts line
    end
  end

end

class TspsDealiasTask

  attr_reader :taskid, :last_reply

  def initialize(taskid, candidates)
    @ipa = candidates[0]
    @ipb = candidates[1]
    @taskid = taskid
    @candidates = candidates
    @last_reply = Time.at(0)

    log("#{@ipa},#{@ipb}: dealiasing starting");

    @dealias_result = DealiasResult.new(@ipa, @ipb)
    @is_complete = false
    @current_state = TspsDealiasSuitabilityTask.new(candidates, 
                                                    @dealias_result)
  end

  def to_s
    "Task: IPA:#{@ipa} IPB:#{@ipb} State:#{@current_state}"
  end

  def current_state
    return nil unless @current_state
    if @current_state.is_complete
      @current_state = @current_state.next_state
    end
    return @current_state
  end

  def next_probe
    current_state().next_probe
  end

  def receive_probe(probe)
    @last_reply = Time.now
    current_state().receive_probe(probe)
  end

  def is_complete
    if current_state() == nil
      log("#{@ipa},#{@ipb}: dealiasing complete");
      puts @dealias_result
      true
    else
      false
    end
  end

end #TspsDealiasTask

class TspsDealiasSuitabilityTask

  attr_reader :is_complete

  def initialize(candidates, dealias_result)
    @dealias_result = dealias_result
    @candidates = candidates

    @subtask = TspsDealiasSuitabilityIpTask.new(@candidates[0], 
                                                @dealias_result)
    @state = :ipa
    # states: :ipa, :ipb, :done
  end

  def next_state
    if @passed
      return TspsDealiasAliasCheckTask.new(@candidates, @dealias_result)
    else
      return nil
    end
  end

  def is_complete
    if @subtask.is_complete
      if @state == :ipa 
        @suit_a_passed = @subtask.passed
        if @candidates[1]
          @state = :ipb
          @subtask = TspsDealiasSuitabilityIpTask.new(@candidates[1],
                                                      @dealias_result)
          return false
        end
      end
      if @state == :ipb
        @suit_b_passed = @subtask.passed
      end
      @state = :done
      if !@dealias_result.overall
        @dealias_result.overall = "INELIGIBLE"
      end
      @passed = @candidates[1] ? @suit_a_passed && @suit_b_passed : 
        @suit_a_passed
      return true
    else
      return false
    end
  end

  def next_probe
    return @subtask.next_probe
  end

  def receive_probe(probe)
    @subtask.receive_probe(probe)
  end

end #TspsDealiasSuitabilityTask

class TspsDealiasSuitabilityIpTask

  X = "192.0.2.0"

  attr_reader :passed

  def initialize(ip, dealias_result)
    @ip = ip
    @dealias_result = dealias_result

    @state = :extra_stamp
    
    @replies = []
    
    @probe_queue = []
    @pending_probes = 0
    # states: :extra_stamp, :double_stamp, :done

    @message = "#{ip}: suitability check"
    @err_message = @message + " failed "
    log(@message)
  end

  def next_probe
    if @probe_queue.length == 0 && @pending_probes == 0
      # get the probes
      if @state == :extra_stamp
        log("#{@ip}: \textra stamp bug check (A|AXXX)")
        @probe_queue = repeat_add(@ip, [@ip, X, X, X])
      elsif @state == :double_stamp
        log("#{@ip}: \tdouble stamp check (A|AAAA)")
        @probe_queue = repeat_add(@ip, [@ip, @ip, @ip, @ip])
      end
    end
    probe = @probe_queue.shift
    @pending_probes += 1 if probe
    return probe
  end

  def receive_probe(probe)
    unless probe
      return
    end
    @replies << probe
    @pending_probes -= 1

    if @replies.length == REPEAT
      process_reply_probes(@replies)
      @replies = []
    end
  end

  def process_reply_probes(replies)
    stamp_types = classify_stamps(@replies)
    if @state == :extra_stamp
      if @ip == @dealias_result.ipa
        dump_replies(@dealias_result, "A|AXXX", replies)
      else
        dump_replies(@dealias_result, "B|BXXX", replies)
      end

      # we must have at least two replys
      if stamp_types[:reply_cnt] < 2
        # we do not have enough replies to have confidence
        log(@err_message + 
            "(#{stamp_types[:no_reply]}/#{REPEAT} probes received no reply)")
        @dealias_result.suit_check << "FNR#{stamp_types[:reply_cnt]}"
        
        #lets tell them to reprobe if we receive only one reply
        if stamp_types[:reply_cnt] == 1
          @dealias_result.overall = "UNKNOWN-REPROBE"
        end
        
        @state = :done
      elsif stamp_types.keys.length > 3 #(no_reply, reply_cnt, x_stamps)
        # more than one stamping behavior is seen
        log(@err_message + "(more than one stamping behavior)")
        @dealias_result.suit_check << "FVS#{stamp_types[:reply_cnt]}"
        
        @state = :done
      elsif stamp_types[:two_stamps] > 0
        log(@err_message + "(extra stamp)")
        @dealias_result.suit_check << "FES#{stamp_types[:reply_cnt]}"
        
        @state = :done
      elsif stamp_types[:no_stamp] > 0
        log(@err_message + "(no stamp)")
        @dealias_result.suit_check << "FNS#{stamp_types[:reply_cnt]}"
        
        @state = :done
      end
      if @state != :done
        @state = :double_stamp
      end
    elsif @state == :double_stamp
      if @ip == @dealias_result.ipa
        dump_replies(@dealias_result, "A|AAAA", replies)
      else
        dump_replies(@dealias_result, "B|BBBB", replies)
      end

      if stamp_types[:reply_cnt] < 2
        # we do not have enough replies to have confidence
        log(@err_message + 
            "(#{stamp_types[:no_reply]}/#{REPEAT} probes received no reply)")
        @dealias_result.suit_check << "FNR#{stamp_types[:reply_cnt]}"
        # tell them to reprobe because we saw replies to (A|AXXX)
        @dealias_result.overall = "UNKNOWN-REPROBE"
        
      elsif stamp_types.keys.length > 3 #(no_reply, reply_cnt, x_stamps)
        # more than one stamping behavior is seen
        log(@err_message + "(more than one stamping behavior)")
        @dealias_result.suit_check << "FVS#{stamp_types[:reply_cnt]}"
        
      elsif stamp_types[:no_stamp] > 0
        log(@err_message + "(no stamp)")
        @dealias_result.suit_check << "FNS#{stamp_types[:reply_cnt]}"
        
      elsif stamp_types[:one_stamp] > 0
        log(@err_message + "(one stamp)")
        @dealias_result.suit_check << "F1S#{stamp_types[:reply_cnt]}"
        
      elsif stamp_types[:four_stamps] > 0
        log(@message + " passed (4 stamps)")
        @dealias_result.suit_check << "P4S#{stamp_types[:reply_cnt]}"
        @passed = true
        
      elsif stamp_types[:three_stamps] > 0
        log(@message + " passed (3 stamps)")
        @dealias_result.suit_check << "P3S#{stamp_types[:reply_cnt]}"
        @passed = true
        
        elsif stamp_types[:two_stamps] > 0
        log(@message + " passed (2 stamps)")
        @dealias_result.suit_check << "P2S#{stamp_types[:reply_cnt]}"

        @passed = true
      else
        # huh? how could we have possibly got here?
        log(@message + "FATAL ERROR: invalid state")
        @dealias_result.suit_check << "XXX"
        @dealias_result.overall = "ERROR"
        
      end
      @state = :done
    end
  end
  
  def is_complete
    if @state == :done
      true
    else
      false
    end
  end

end #TspsDealiasSuitabilityIpTask

class TspsDealiasAliasCheckTask

  attr_reader :is_complete

  def initialize(candidates, dealias_result)
    @dealias_result = dealias_result
    @candidates = candidates
    @ipa = @candidates[0]
    @ipb = @candidates[1]

    @probe_queue = []
    @pending_probes = 0

    @replies = []

    @stamps_a = {} # the stamps for (A|ABAB)
    @stamps_b = {} # the stamps for (B|BABA)

    @state = :probe_ipa
    # states: :probe_ipa, :probe_ipb, :ret_path_check

    @message = "#{@ipa},#{@ipb}: dealias check"
    @err_message = @message + " failed "
    log(@message)
  end

  def next_state
    return nil
    #if @passed
    #  return TspsDealiasAliasCheckTask.new(@candidates, @dealias_result)
    #else
    #  return nil
    #end
  end

  def is_complete
    if @state == :probe_ipa || @state == :probe_ipb
        return false
    end
    if @state == :done
      return true
    end
    if @state == :ret_path_check
      return @subtask.is_complete
    end
    if @state == :shared_clock
      if @subtask.is_complete
        if @subtask.passed
          @subtask = TspsDealiasDistanceLoopTask.new((@probes_a | @probes_b), 
                                                     @ipa, @ipb,
                                                     @dealias_result)
          @state = :distance_loop
        else
          return true
        end
      end
      return false
    end
    if @state == :distance_loop
      return @subtask.is_complete
    end
  end

  def next_probe
    if @state == :probe_ipa || @state == :probe_ipb
      if @probe_queue.length == 0 && @pending_probes == 0
        # get the probes
        if @state == :probe_ipa
          log("#{@ipa}: \tdealias check (A|ABAB)")
          @probe_queue = repeat_add(@ipa, [@ipa, @ipb, @ipa, @ipb])
        elsif @state == :probe_ipb
          log("#{@ipb}: \tdealias check (B|BABA)")
          @probe_queue = repeat_add(@ipb, [@ipb, @ipa, @ipb, @ipa])
        end
      end
      probe = @probe_queue.shift
      @pending_probes += 1 if probe
      return probe
    else
      return @subtask.next_probe
    end
  end

  def receive_probe(probe)
    if @state == :probe_ipa || @state == :probe_ipb
      unless probe
        return
      end
      @replies << probe
      @pending_probes -= 1
      
      if @replies.length == REPEAT
        process_reply_probes(@replies)
        @replies = []
        if @state == :check_validity
          a_valid = check_validity(@probes_a, @stamps_a, @ipa, 
                                   @dealias_result.suit_check[0])
          b_valid = check_validity(@probes_b, @stamps_b, @ipb, 
                                   @dealias_result.suit_check[1])

          if !a_valid || !b_valid
            if @dealias_result.alias_validity_check[0] == "F1S" &&
                @dealias_result.alias_validity_check[1] == "P2S"
              @subtask = TspsDealiasRetPathCheckTask.new(@ipa, @ipb, 
                                                         @dealias_result)
              @state = :ret_path_check
              return
            elsif @dealias_result.alias_validity_check[0] == "P2S" &&
                @dealias_result.alias_validity_check[1] == "F1S"
              @subtask = TspsDealiasRetPathCheckTask.new(@ipb, @ipa, 
                                                         @dealias_result)
              @state = :ret_path_check
              return
              #return ret_path_check(ipb, ipa)
            else
              @state = :done
              return
            end
          else
            stamp_types = classify_stamps(@probes_a | @probes_b)

            passed_cnt = stamp_types[:two_stamps] + stamp_types[:three_stamps] +
              stamp_types[:four_stamps]
            
            # be sure that we have a total of REPEAT stamps (50%) 
            # to base the analysis on
            if passed_cnt < REPEAT
              log(@err_message + 
                  "(#{passed_cnt} of #{REPEAT}" +
                  " required probes with >=2 stamps)")
              @dealias_result.alias_check = "FIR"
              @dealias_result.overall = "UNKNOWN-REPROBE"
              @state = :done
              return
            end
            
            # these need to be split because we have to be sure that BOTH a and b
            # have replied with four stamps
            if @stamps_a[:four_stamps] > 0 && @stamps_b[:four_stamps] > 0
              log(@message + " passed (4 stamps)")
              @dealias_result.alias_check = "P4S"
              @dealias_result.overall = "ALIAS"
              @state = :done
              return
            elsif (@stamps_a[:two_stamps] > 0 && 
                   @stamps_b[:four_stamps] > 0) ||
                (@stamps_a[:four_stamps] && 
                 @stamps_b[:two_stamps] > 0)
              log(@message + " passed (2 stamps)")
              @dealias_result.alias_check = "P2S"
              @state = :shared_clock
              @subtask = TspsDealiasSharedClockTask.new((@probes_a | @probes_b),
                                                        @ipa, @ipb, 
                                                        @dealias_result)
              return
            elsif stamp_types[:three_stamps] > 0
              log(@err_message + "(three stamps received)")
              @dealias_result.alias_check = "F3S"
              @dealias_result.overall = "ERROR"
              @state = :done
              return
            end
          end
        end
      end
    else
      @subtask.receive_probe(probe)
    end
  end

  def process_reply_probes(replies)
    stamp_types = classify_stamps(@replies)
    if @state == :probe_ipa
      dump_replies(@dealias_result, "A|ABAB", replies)
      @probes_a = @replies
      @stamps_a = stamp_types
      @state = :probe_ipb
    else
      dump_replies(@dealias_result, "B|BABA", replies)
      @probes_b = @replies
      @stamps_b = stamp_types
      @state = :check_validity
    end
  end

  def check_validity(probes, stamp_types, ip, suitresult)
    message = "#{ip}: \tvalidity check"
    err_message = message + " failed "
    log(message)

    if stamp_types[:reply_cnt] == 0
      log(err_message + "(no replies)")
      @dealias_result.alias_validity_check << "FNR"
      @dealias_result.overall = "UNKNOWN-REPROBE" unless @dealias_result.overall
      return false
    end

    if stamp_types.keys.length > 3
      log(err_message + "(multiple stamping behvaiors seen)")
      @dealias_result.alias_validity_check << "FVS"
      @dealias_result.overall = "INELIGIBLE" unless @dealias_result.overall
      return false
    end

    if suitresult =~ /P4S/ || suitresult =~ /P2S/
      if suitresult =~ /P4S/ && stamp_types[:two_stamps] > 0
        dec_cnt = 0
        probes.each do |probe|
          result = probe.result
          if (result.reply_tsps_ts1 - result.reply_tsps_ts2 > 0) ||
              (result.reply_tsps_ts2 - result.reply_tsps_ts1 > 1)
            dec_cnt += 1
          end
        end
        # went from a 4stamp to a 2stamp
        # if ts1-ts2 > 0 || ts2-ts1 > 1 more than once
        if dec_cnt > 1
          log(err_message + "(4->2 stamps indicating reverse path STRONG)")
          @dealias_result.alias_validity_check << "FRS"
        else
          log(err_message + "(4->2 stamps indicating reverse path WEAK)")
          @dealias_result.alias_validity_check << "FRW"
        end
        @dealias_result.overall = "NOALIAS"
        return false
      elsif (suitresult =~ /P4S/ && stamp_types[:three_stamps] > 0) ||
          (suitresult =~ /P2S/ && stamp_types[:three_stamps] > 0)
        dec_cnt = 0
        probes.each do |probe|
          result = probe.result
          if (result.reply_tsps_ts1 - result.reply_tsps_ts2 > 0 &&
              result.reply_tsps_ts2 - result.reply_tsps_ts3 > 0) ||
              (result.reply_tsps_ts3 - result.reply_tsps_ts3 > 1 &&
               result.reply_tsps_ts2 - result.reply_tsps_ts1 > 1)
            dec_cnt += 1
          end
        end
        # went from a 4stamp to a 3stamp
        # if (ts1-ts2 > 0 && ts2-ts3 < 0) || (ts3-ts2 > 1 && ts2-ts1 >1) once
        if dec_cnt > 1
          log(err_message + "(4|2->3 stamps indicating reverse path STRONG)")
          @dealias_result.alias_validity_check << "FRS"
        else
          log(err_message + "(4|2->3 stamps indicating reverse path WEAK)")
          @dealias_result.alias_validity_check << "FRW"
        end
        @dealias_result.overall = "NOALIAS"
      end
    end
    
    if stamp_types[:no_stamp] > 0
      log(err_message + "(no stamps)")
      @dealias_result.alias_validity_check << "FNS"
      @dealias_result.overall = "ERROR"
      return false
    end

    if stamp_types[:one_stamp] > 0 
      log(err_message + "(one stamp)")
      @dealias_result.alias_validity_check << "F1S"
      @dealias_result.overall = "UNKNOWN" unless @dealias_result.overall
      return false
    end

    if stamp_types[:two_stamps] > 0
      log(message + " passed (two stamps)")
      @dealias_result.alias_validity_check << "P2S"
      return true
    end

    if stamp_types[:three_stamps] > 0
      #leave this as a pass for the moment
      #it'll soon get weeded out
      log(message + " passed (three stamps)")
      @dealias_result.alias_validity_check << "P3S"
      return false
    end

    if stamp_types[:four_stamps] > 0
      log(message + " passed (four stamps)")
      @dealias_result.alias_validity_check << "P4S"
      return true
    end

    @dealias_result.alias_validity_check << "XXX"
    @dealias_result.overall = "ERROR"
  end


end #TspsDealiasAliasCheckTask


class TspsDealiasRetPathCheckTask

  attr_reader :is_complete

  def initialize(ipa, ipb, dealias_result)
    @dealias_result = dealias_result
    @ipa = ipa
    @ipb = ipb

    @probe_queue = []
    @pending_probes = 0

    @replies = []

    @state = :probe
    # states: :probe, :done

    @message = "#{@ipa},#{@ipb}: return path check"
    @err_message = @message + " completed "
    log(@message)
  end

  def is_complete
    if @state == :probe
        return false
    end
    if @state == :done
      return true
    end
  end

  def next_probe
    if @probe_queue.length == 0 && @pending_probes == 0
      # get the probes
      log("#{@ipa},#{@ipb}: " +
          "\tchecking for #{@ipa} in the path to #{@ipb} (A|BABA)")
      @probe_queue = repeat_add(@ipb, [@ipa, @ipb, @ipa, @ipb])
    end
    probe = @probe_queue.shift
    @pending_probes += 1 if probe
    return probe
  end

  def receive_probe(probe)
    unless probe
      return
    end
    @replies << probe
    @pending_probes -= 1
    
    if @replies.length == REPEAT
      process_reply_probes(@replies)
      @replies = []
    end
  end
  
  def process_reply_probes(probes)
    if @ipa == @dealias_result.ipa
      dump_replies(@dealias_result, "B|ABAB", probes)
    else
      dump_replies(@dealias_result, "A|BABA", probes)
    end
    stamp_types = classify_stamps(probes)
    
    if stamp_types[:reply_cnt] == 0
      log(@err_message + "(no reply)")
      @dealias_result.ret_path = "FNR"
      @dealias_result.overall = "UNKNOWN-REPROBE"
    end
    
    if stamp_types.keys.length > 3
      log(!err_message + "(multiple stamping behvaiors seen)")
      @dealias_result.ret_path = "FVS"
      @dealias_result.overall = "INELIGIBLE"
    end
    
    if stamp_types[:no_stamp] > 0
      log(@err_message + "(no stamps)")
      @dealias_result.ret_path = "FNS"
      @dealias_result.overall = "UNKNOWN-NOALIAS"
    end

    if stamp_types[:one_stamp] > 0 
      log(@err_message + "(one stamp)")
      @dealias_result.ret_path = "F1S"
      @dealias_result.overall = "ERROR"
    end

    if stamp_types[:two_stamps] > 0
      log(@err_message + "(two stamps)")
      @dealias_result.ret_path = "F2S"
      @dealias_result.overall = "UNKNOWN-NOALIAS"
    end

    if stamp_types[:three_stamps] > 0
      log(@err_message + "(three stamps)")
      @dealias_result.ret_path = "F3S"
      @dealias_result.overall = "NOALIAS"
    end

    if stamp_types[:four_stamps] > 0
      log(@err_message + "(four stamps)")
      @dealias_result.ret_path = "F4S"
      @dealias_result.overall = "ERROR"
    end

    @state = :done
  end

end #TspsDealiasRetPathCheckTask

class TspsDealiasSharedClockTask

  def initialize(probes, ipa, ipb, dealias_result)
    @probes = probes
    @ipa = ipa
    @ipb = ipb
    @dealias_result = dealias_result

    @probe_queue = []
    @pending_probes = 0

    @replies = []

    @state = :done
    # states: :regular, :midnight_epoch_a, :midnight_epoch_b, :done

    @message = "#{@ipa},#{@ipb}: shared clock check"
    @err_message = @message + " failed "
    log(@message)

    process_probes_init
  end

  def process_probes_init
    @passed_cnt = 0
    dec_ts = 0
    mid_epoch_cnt = 0

    stamp_types = classify_stamps(@probes)

    @probes.each do |task|
      result = task.result
      stamp_one_type = nil
      stamp_two_type = nil
      max_stamp = nil
      task_pass = true
      if result.reply_tsps_ts1
        max_stamp = result.reply_tsps_ts1
        stamp_one_type = classify_time_type(result.reply_tsps_ts1)
      end
      if result.reply_tsps_ts2
        stamp_two_type = classify_time_type(result.reply_tsps_ts2)
        if max_stamp > result.reply_tsps_ts2
          dec_ts += 1
        elsif max_stamp < result.reply_tsps_ts2
          max_stamp = result.reply_tsps_ts2
          task_pass = false
        end
      end
      if result.reply_tsps_ts3
        if max_stamp > result.reply_tsps_ts3
          dec_ts += 1
        elsif max_stamp < result.reply_tsps_ts3
          max_stamp = result.reply_tsps_ts3
          task_pass = false
        end
      end
      if result.reply_tsps_ts4
        if max_stamp > result.reply_tsps_ts4
          dec_ts += 1
        elsif max_stamp < result.reply_tsps_ts4
          max_stamp = result.reply_tsps_ts4
          task_pass = false
        end
      end

      mid_epoch_cnt += 1 if (stamp_one_type == :midnight_offset && 
        stamp_two_type == :epoch)

      @passed_cnt += 1 if task_pass 
    end

    # check for decrementing timestamps
    if dec_ts > 0
      log(@err_message + "(decrementing timestamp)")
      @dealias_result.shared_clk = "FDT#{dec_ts}"
      @dealias_result.overall = dec_ts == 0 ? "UNKNOWN-REPROBE" : "NOALIAS"
      @state = :done
      return
    end
          
    if mid_epoch_cnt == stamp_types[:two_stamps]
      @state = :midnight_epoch_a
      return
    end

    finish_probe_check

  end

  def passed
    return @state == :passed
  end

  def is_complete
    if @state == :done || @state == :passed
      return true
    end
    return false
  end

  def next_probe
    if @probe_queue.length == 0 && @pending_probes == 0
      # get the probes
      if @state == :midnight_epoch_a
        log("#{@ipa}: \tmidnight/epoch behavior check (A|BBBB)")
        @probe_queue = repeat_add(@ipa, [@ipb, @ipb, @ipb, @ipb])
      elsif @state == :midnight_epoch_b
        log("#{@ipb}: \tmidnight/epoch behavior check (B|AAAA)")
        @probe_queue = repeat_add(@ipb, [@ipa, @ipa, @ipa, @ipa])
      end
    end
    probe = @probe_queue.shift
    @pending_probes += 1 if probe
    return probe
  end

  def receive_probe(probe)
    unless probe
      return
    end
    @replies << probe
    @pending_probes -= 1
    
    if @replies.length == REPEAT
      process_reply_probes(@replies)
      @replies = []
    end
  end

  def process_reply_probes(replies)
    stamp_types = classify_stamps(replies)
    if @state == :midnight_epoch_a
      dump_replies(@dealias_result, "A|BBBB", replies)
      @ipa_offset = stamp_types[:two_stamps] > 0 && 
        is_midnight_offset(replies, stamp_types)
      @state = :midnight_epoch_b
    elsif @state == :midnight_epoch_b
      dump_replies(@dealias_result, "B|AAAA", replies)
      @ipb_offset = stamp_types[:two_stamps] > 0 && 
        is_midnight_offset(replies, stamp_types)
      if @ipa_offset && @ipb_offset
        log(@message + " passed (midnight/epoch behavior)")
        @dealias_result.shared_clk = "PME"
        @dealias_result.overall = "ALIAS"
        @state = :passed
        return
      end

      finish_probe_check
    end
  end

  def finish_probe_check
    shared_clk_pct = (@passed_cnt/@probes.length.to_f)*100
    if shared_clk_pct >= 90
      log(@message + " passed (#{shared_clk_pct}% shared clocks)")
      @dealias_result.shared_clk = "PSC"
      @state = :passed
      return
    else
      log(@err_message + "#{shared_clk_pct}% shared clocks (90% required)")
      @dealias_result.shared_clk = "F90"
      @dealias_result.overall = "UNKNOWN-NOALIAS"
      @state = :done
      return
    end
  end

  def classify_time_type(timestamp)
    if timestamp > 0 && timestamp < 86400000
      return :midnight_offset
    elsif timestamp < 0 || timestamp > 4294967296
      return :nonstandard
    elsif timestamp == 0
      return :zero
    else
      return :epoch
    end
  end

  def is_midnight_offset(tasks, stamp_types)
    mid_epoch_cnt = 0
    tasks.each do |task|
      stamp_one_type = nil
      stamp_two_type = nil
      result = task.result
      if result.reply_tsps_ts1
        stamp_one_type = classify_time_type(result.reply_tsps_ts1)
      end

      if result.reply_tsps_ts2
        stamp_two_type = classify_time_type(result.reply_tsps_ts2)
      end

      if stamp_one_type == :midnight_offset && stamp_two_type == :epoch
        mid_epoch_cnt += 1
      end
    end

    if mid_epoch_cnt == stamp_types[:two_stamps]
      return true
    else
      return false
    end
  end


end #TspsDealiaSharedClockTask

class TspsDealiasDistanceLoopTask

  attr_reader :is_complete
  
  def initialize(probes, ipa, ipb, dealias_result)
    @probes = probes
    @ipa = ipa
    @ipb = ipb
    @dealias_result = dealias_result

    @probe_queue = []
    @pending_probes = 0

    @replies = []

    @stamps_a = {} # the stamps for (A|ABAB)
    @stamps_b = {} # the stamps for (B|BABA)

    @state = :probe_ipa
    # states: :probe_ipa, :probe_ipb, :done

    @message = "#{@ipa},#{@ipb}: distance/loop check"
    @err_message = @message + " failed "
    log(@message)
  end

  def next_state
    return nil
  end

  def is_complete
    return @state == :done
  end

  def next_probe
    if @probe_queue.length == 0 && @pending_probes == 0
      # get the probes
      if @state == :probe_ipa
        log("#{@ipa}: \tcheck reverse distance")
        @probe_queue = repeat_add(@ipa, nil)
      elsif @state == :probe_ipb
        log("#{@ipb}: \tcheck reverse distance")
        @probe_queue = repeat_add(@ipb, nil)
      end
    end
    probe = @probe_queue.shift
    @pending_probes += 1 if probe
    return probe
  end

  def receive_probe(probe)
    unless probe
      return
    end
    @replies << probe
    @pending_probes -= 1
    
    if @replies.length == REPEAT
      process_reply_probes(@replies)
      @replies = []
    end
  end

  def process_reply_probes(replies)
    if @state == :probe_ipa
      dump_replies(@dealias_result, "A|", replies)
      @ipa_ttl = get_return_ttl(@ipa, replies)
      @state = :probe_ipb
      return
    else
      dump_replies(@dealias_result, "B|", replies)
      @ipb_ttl = get_return_ttl(@ipb, replies)
      
      unless @ipa_ttl && @ipb_ttl
        @dealias_result.overall = "UNKNOWN-REPROBE"
        @state = :done
        return
      end

      if @ipa_ttl != @ipb_ttl
        log(@err_message + "A(#{@ipa_ttl}) and B(#{@ipb_ttl}) not equidistant")
        @dealias_result.distance_loop = "FDI"
        @dealias_result.overall = "UNKNOWN-NOALIAS"
        @state = :done
        return
      end

      log(@message + " passed (A(#{@ipa_ttl}) == B=(#{@ipb_ttl}))")
      @dealias_result.distance_loop = "PDI"
      @dealias_result.overall = "ALIAS"
      @state = :done
      return
    end
  end

  def get_return_ttl(ip, tasks)
    message = "#{ip}: \testablishing return distance"
    err_message = message + " failed "
    log(message)

    ttl = nil
    noreply = 0
    tasks.each do |task|
      if task.result.responded?
        ttl = task.result.reply_ttl if ttl == nil
        if task.result.reply_ttl != ttl
          log(err_message + "reply ttl varies")
          @dealias_result.distance_loop = "FTV"
          return nil
        end
      else
        noreply += 1
      end
    end
    
    if noreply == REPEAT
      log(err_message + "no reply")
      @dealias_result.distance_loop = "FNR#{noreply}"
      return nil
    end

    return ttl
  end

end #TspsDealiasDistanceLoopTask

#################################################################################
# STATIC HELPER METHODS
#################################################################################

def repeat_add(dest, tsps_ips)
  queue = []
  REPEAT.times do 
    queue << Probe.new(dest, tsps_ips)
  end
  return queue
end

def classify_stamps(probes)
  stamp_types = Hash.new(0)
  stamp_types[:no_reply] = 0 #ensure that there is always a key for this
  probes.each do |probe|
    stamp_types[count_stamps(probe.result)] += 1
    stamp_types[:reply_cnt] += 1 if probe.result.responded?
  end
  stamp_types
end

def count_stamps(result)
  return :no_reply if !result.responded?
  return :four_stamps if result.reply_tsps_ts4
  return :three_stamps if result.reply_tsps_ts3
  return :two_stamps if result.reply_tsps_ts2
  return :one_stamp if result.reply_tsps_ts1
  return :no_stamp
end

def log(message)
  $stderr.puts message if $options.full
end

def rtt(result)
  return "-" if !result.responded?
  tx = Time.at(result.tx_sec, result.tx_usec)
  rx = Time.at(result.rx_sec, result.rx_usec)
  (rx-tx) * 1000
end

def dump_replies(dealias_result, type_str, probes)
  probes.each do |probe|
    result = probe.result
    if result.reply_tsps_ip1
      ts_str = result.reply_tsps_ip1 + "=" + result.reply_tsps_ts1.to_s
      if result.reply_tsps_ip2
        ts_str += "," + result.reply_tsps_ip2 + "=" + 
          result.reply_tsps_ts2.to_s
        if result.reply_tsps_ip3
          ts_str += "," + result.reply_tsps_ip3 + "=" + 
            result.reply_tsps_ts3.to_s
          if result.reply_tsps_ip4
            ts_str += "," + result.reply_tsps_ip4 + "=" + 
              result.reply_tsps_ts4.to_s
          end
        end
      end
    else
      ts_str = "-"
    end
    # dest|type_str|ts_str|reply_ttl|rtt
    dealias_result.verbose << sprintf("< %s,%s|%s|%s|%s|%s\n", 
                                      @dealias_result.ipa, @dealias_result.ipb,
                                      type_str, ts_str, 
                                      result.reply_ttl || "-", rtt(result))
  end
end

#################################################################################

dealiasManager = TspsDealiasManager.new
dealiasManager.start
