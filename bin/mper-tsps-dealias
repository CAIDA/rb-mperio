#!/usr/bin/env ruby

#################################################################################
## Implements the IP Prespecified Timestamp dealias method described in
## "Resolving IP Aliases with Prespecified Timestamps", Sherry et al., IMC'10
##
## There is one line of output for each pair of candidate addresses (IPa,IPb), 
## as follows:
## <candidate_pair>|<suitability_check>|<alias_validity_check|<reverse_path>
##   <alias_check>|<shared_clk>|<distance_loop>|<overall>
##
## The structure and possible values in each section are listed below:
##
## <candidate_pair> MANDATORY
##   IPa,IPb
##   e.g. 192.168.1.1,192.168.1.2
##
## <suitability_check> MANDATORY
##   <result>,<result>
##   The suitability check is performed on each address.
##   
##   The possible result values are:
##     P4Sx => Pass, 4 Stamps
##     P3Sx => Pass, 3 Stamps
##     P2Sx => Pass, 2 Stamps
##     F1Sx => Fail, One Stamp
##     FNSx => Fail, No Stamp
##     FNRx => Fail, No Reply
##     FESx => Fail, Extra Stamp
##     FVSx => Fail, Varying Stamps (multiple stamping behaviours were oberved)
##      (where x is the number of probes that were replied to)
## 
## <alias_validity_check> OPTIONAL
##   <result>,<result>
##   The alias validity check is only performed if both IPa and IPb pass the 
##   suitability check.
##
##   Possible values are:
##     P2S => Pass, Two Stamps
##     P3S => Pass, Three Stamps (weeded out in alias check)
##     P4S => Pass, Four Stamps
##     FNR => Fail, No Reply 
##     F1S => Fail, One Stamp
##     FNS => Fail, No Stamps
##     FVS => Fail, Varying Stamps (multiple stamping behaviours were oberved)
##     FRP => Fail, Reverse Path (a 4 stamper elicited 2 or 3 stamps) (NOALIAS)
##
## <reverse_path> OPTIONAL
##   The reverse path check is only performed if 
##   (IPa==P2S && IPb==F1S) || (IPa==F1S && IPb==P2S)
##   Works by probing the P2S interface (A) with (A|BABA) to determine if B
##   is in fact in the return path from A.
##
##   Possible values are:
##     FNR => Fail, No Reply
##     FVS => Fail, Varying Stamps
##     FNS => Not enough data to make a conclusion (UNKNOWN-NOALIAS)
##     F1S => Should not happen (load balancing?) (ERROR)
##     F2S => A is in the fwd path, but not reverse? (UNKNOWN-NOALIAS)
##     F3S => A is in both fwd and reverse path (NOALIAS)
##     F4S => Should not happen (ERROR)
##
## <alias_check> OPTIONAL
##   The alias check is only performed if both IPa and IPb pass the 
##   validity check
##
##   Possible values are:
##     P2S => Pass, Two Stamps
##     P4S => Pass, Four Stamps (indicates an alias)
##     F3S => Fail, Three Stamps (an error condition)
##     FIR => Fail, Insufficient Stamps (50% total replies are required)
##
## <shared_clk> OPTIONAL
##   The shared clock test is only performed if the alias check test is
##   passed with the PTS flag, indicating that the replies were stamped
##   twice.
##
##   Possible values are:
##     PSC  => Pass, Shared Clock
##     PME  => Pass, Midnight/Epoch
##     FDT  => Fail, Decreasing Timestamp
##     F90  => Fail, less than 90% stamp consistency
##
## <distance_loop> OPTIONAL
##   The distance/loop test is only preformed if the shared clock test is
##   passed with the PSC flag.
##
##   Possible values are:
##     PDI  => Pass, Distance
##     FNRx => Fail, No Reply (where x is the number of noreplies)
##     FTV  => Fail, TTL Variance (within the probes to a single interface)
##
## <overall> MANDATORY
##   The overall value is the end result of performing the dealias algorithm
##   on the candidate pair.
## 
##   Possible values are:
##     ALIAS            => Confirmed as aliases.
##     NOALIAS          => Confirmed to not be aliases.
##     UNKNOWN          => A determination could not be made.
##     UNKNOWN-REPROBE  => Could potentially be resolved by reprobing.
##     UNKNOWN-ALIAS    => Are probably aliases but cannot be confirmed.
##     UNKNOWN-NOALIAS  => Are probably not aliases but cannot be confirmed
##     INELIGIBLE => The candidate interfaces were not suitable for this
##                   technique.
##     ERROR      => An unexpected result not handled by the algorithm.
##
#############################################################################

if $0 =~ /dev$/
  $: << "#{ENV['HOME']}/caida/rb-mperio/ext"
  $: << "#{ENV['HOME']}/caida/rb-mperio/lib"
else
  require 'rubygems'
end

require 'ostruct'
require 'optparse'

require 'mperio'

$options = OpenStruct.new
$options.spacing = 0
$options.log_path = nil  # disable logging by default

opts = OptionParser.new

opts.banner="usage: #{$0} [-?fv] [-n concurrency] [-s spacing] [-l logfile]\n"\
 + " " * $0.to_s.length + "        -p mperport -c candidatefile | IPa IPb"

opts.on("-p", "--mper-port=NUM", Integer,
	"mper control socket port (REQUIRED)") do |v|
  $options.mper_port = v
end

opts.on("-c", "--candidates=PATH",
        "file with candidate pair information") do |v|
  $options.candidate_path = v
end

opts.on("-n", "--concurrency=NUM", Integer,
        "max pairs to dealias concurrently (default: unlimited)") do |v|
  $options.concurrency = v
end

opts.on("-s", "--spacing=NUM", Integer,
        "spacing (ms) between probes (default: #{$options.spacing})") do |v|
  $options.spacing = v
end

opts.on("-f", "--full", TrueClass, "show full result output") do |v|
  $options.full = v
end

opts.on("-v", "--[no-]verbose", TrueClass,  "show detailed progress") do |v|
  $options.verbose = v
end

opts.on("-l", "--log=PATH", "mper command/result message log path") do |v|
  $options.log_path = v
end

opts.on_tail("-?", "--help", "show this message") do
  puts opts
  exit
end

begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!.to_s + "\n\n"
  $stderr.puts opts
  exit 1
end

unless $options.mper_port
  $stderr.puts "ERROR: missing mper port\n\n"
  $stderr.puts opts
  exit -1
end

# change the IPa and IPb options to allow a list of IPa,IPb pairs
# when we get to the point where we can resolve multiple pairs
unless $options.candidate_path || ARGV.length == 2
  $stderr.puts "ERROR: candidate file path "\
    "or both IPa and IPb must be specified\n\n"
  $stderr.puts opts
  exit -1
end

#============================================================================

class CandidateFile

  attr_reader :candidates

  def initialize(candidate_path)
    @candidate_path = candidate_path
    @candidate_io = File.open candidate_path
    @done = false
  end

  def next_candidate
    return nil if @done
    loop do
      line = @candidate_io.gets
      if line
        next if line =~ /^\#/ || line =~ /^\s*$/
        line.chomp!
        if line =~ /,/
          @candidates = line.split(",")
        else
          @candidates = line.split(" ")
        end
        return @candidates
      else
        @done = true
        return nil
      end
    end
  end

end


#============================================================================
##
## TODO: When we get the ability to process more than one candidate pair,
##       modify this class to hold the list of pairs and return a new
##       one each time next_candidates is called
##
class ImmediateCandidates

  def initialize(ipa, ipb)
    @ipa = validate_ip(ipa)
    @ipb = validate_ip(ipb)
  end
  
  def validate_ip(ip)
    if ip =~ /^\d+\.\d+\.\d+\.\d+$/
      ip
    else
      $stderr.puts "ERROR: malformed candidate ip: \"#{ip}\""
      exit -1
    end
  end
  
  def next_candidate
    if @done
      nil
    else
      @done = true
      [@ipa, @ipb]
    end
  end

end

#============================================================================

class Task
  attr_accessor :id, :dest, :tsps_ips, :result
  
  def initialize(dest, tsps_ips)
    self.dest = dest
    self.tsps_ips = tsps_ips
  end

  def to_s
    "Task #{id}: (#{dest}|#{tsps_ips.join(',')})"
  end
    
end

#============================================================================

class Prober

  class TargetID
    attr_reader :id

    def initialize
      @id = 1  # don't use id == 0
    end

    def advance
      @retval = @id
      @id += 1  # unlikely to ever wrap... famous last words
      @retval
    end
  end

  def initialize(mperio)
    @queued_tasks = []
    @pending_tasks = {}
    @completed_tasks = []
 
    @mperio = mperio
    @mperio.delegate = self

    @next_task_id = TargetID.new

    @reached_concurrency = false
  end

  def add_task(task)
    @queued_tasks << task
   end

  def probe
    @task_count = @queued_tasks.length
    @mperio.start
    ret_tasks = @completed_tasks
    @completed_tasks = []
    ret_tasks
  end

  def stop
    @mperio.stop
  end

  private
  def _do_task
    task = @queued_tasks.pop
    unless task
      $stderr.puts "DEBUG (_do_task): task list empty"
      return
    end
    task.id = @next_task_id.advance
    @pending_tasks[task.id] = task
    tsps_ips_s = (task.tsps_ips) ? task.tsps_ips.join(',') : ""
    printf "probing (%s|%s) @ %d\n", 
      task.dest, tsps_ips_s, task.id if $options.verbose
    @mperio.ping_icmp task.id, task.dest, $options.spacing, task.tsps_ips
  end


  def mperio_on_more
    puts "more" if $options.verbose
    # if the user wants their probes spaced, we can only send one at a time
    if $options.spacing && @pending_tasks.length >= 1
    #if $options.concurrency && @pending_tasks.length >= $options.concurrency
      @reached_concurrency = true
      return  # submit next task in mperio_on_data when a slot becomes free
    end

    if @queued_tasks.length == 0
      if @pending_tasks.length == 0
        @mperio.suspend
      end
    else
      _do_task
    end
  end

  def mperio_on_data(result)
    printf "mperio_on_data: %p\n", result if $options.verbose

    task = @pending_tasks.delete result.reqnum

    if task
      task.result = result
      @completed_tasks << task
    else
      $stderr.puts "pending task not found for id #{result.reqnum}"
      exit -1
    end

    if @pending_tasks.length == 0 && @queued_tasks.length == 0
      @mperio.suspend
    end

    if @reached_concurrency
      @reached_concurrency = false
      mperio_on_more()
    end
  end


  def mperio_on_error(reqnum, message)
    $stderr.printf "mperio_on_error: reqnum=%d msg=%s\n", reqnum, message
    @mperio.stop
    exit 1
  end


  def mperio_on_send_error(reqnum, message)
    $stderr.printf "mperio_on_send_error: reqnum=%d msg=%s\n", reqnum, message
    @pending_tasks.remove reqnum
    @mperio.suspend if @pending_tasks.length == 0 && @queued_tasks.length == 0
  end


  def mperio_service_failure(message)
    $stderr.printf "mperio_service_failure: %s\n", message
    @mperio.stop
    exit 1
  end

end

#============================================================================
class TspsDealiasManager
  
  def initialize
    if $options.candidate_path
      @candidates = CandidateFile.new $options.candidate_path
    else
      @candidates = ImmediateCandidates.new ARGV[0], ARGV[1]
    end

    begin
      @mperio = MperIO.new $options.mper_port, $options.log_path
      @prober = Prober.new mperio
    rescue
      $stderr.puts "Failed to connect to mper on port " +
        "#{$options.mper_port}. Is mper running?"
    end

  end

  def start
    
    dealias = TspsDealias.new prober, candidates
    dealias.start
  end

end

class TspsDealias < Thread

  class DealiasResult
    
    attr_reader :ipa, :ipb
    attr_accessor :suit_check, :alias_validity_check, :ret_path, :alias_check
    attr_accessor :shared_clk, :distance_loop, :overall

    def initialize(ipa, ipb)
      @ipa = ipa
      @ipb = ipb
      @suit_check = []
      @alias_validity_check = []
      @ret_path = "-"
      @alias_check = "-"
      @shared_clk = "-"
      @distance_loop = "-"
    end

    def to_s
      @alias_validity_check[0] = "-" unless @alias_validity_check[0]
      @alias_validity_check[1] = "-" unless @alias_validity_check[1]
      result = sprintf("%s,%s|%s,%s|%s,%s|%s|%s|%s|%s|%s", 
                       @ipa, @ipb, @suit_check[0], @suit_check[1],
                       @alias_validity_check[0], @alias_validity_check[1],
                       @ret_path, @alias_check, @shared_clk, @distance_loop,
                       @overall)
    end

  end

  X = "192.0.2.0"
  REPEAT = 5

  def initialize(prober, candidates)
    @prober = prober
    @candidates = candidates
  end

  def start
    # start dealiasing the 'list' of candidates
    # @ips = @candidates.next_candidate
    while (@ips = @candidates.next_candidate) != nil
      @ipa = @ips[0]
      @ipb = @ips[1]

      @dealias_result = DealiasResult.new(@ipa, @ipb)

      # check suitability for dealiasing
      # Pulling these out like this lets us check both for suitability even 
      # if @ipa is not suitable.
      # This is not the most efficient method, but it means we get some nicer
      # stats on the interfaces
      a_suitable = check_suitability(@ipa)
      b_suitable = check_suitability(@ipb)
      if a_suitable && b_suitable
        # the actual dealias tests
        check_alias @ipa, @ipb
      elsif !@dealias_result.overall
        @dealias_result.overall = "INELIGIBLE"
      end

      $stdout.puts @dealias_result.to_s
    end
    @prober.stop
  end

  def repeat_add(dest, tsps_ips)
    REPEAT.times do 
      @prober.add_task(Task.new(dest, tsps_ips))
    end
  end

  def check_suitability(ip)
    message = "#{ip}: suitability check"
    err_message = message + " failed "
    log(message)

    #check for single stamp with (A|AXXX)
    log("#{ip}: \textra stamp bug check (A|AXXX)")
    repeat_add(ip, [ip, X, X, X])
    tasks = @prober.probe

    stamp_types = classify_stamps(tasks)

    # we must have at least two replys
    if stamp_types[:reply_cnt] < 2
      # we do not have enough replies to have confidence
      log(err_message + 
          "(#{stamp_types[:no_reply]}/#{REPEAT} probes received no reply)")
      @dealias_result.suit_check << "FNR#{stamp_types[:reply_cnt]}"
      
      #lets tell them to reprobe if we receive only one reply
      if stamp_types[:reply_cnt] == 1
        @dealias_result.overall = "UNKNOWN-REPROBE"
      end

      return false
    elsif stamp_types.keys.length > 3 #(no_reply, reply_cnt, x_stamps)
      # more than one stamping behavior is seen
      log(err_message + "(more than one stamping behavior)")
      @dealias_result.suit_check << "FVS#{stamp_types[:reply_cnt]}"
      return false
    elsif stamp_types[:two_stamps] > 0
      log(err_message + "(extra stamp)")
      @dealias_result.suit_check << "FES#{stamp_types[:reply_cnt]}"
      return false
    elsif stamp_types[:no_stamp] > 0
      log(err_message + "(no stamp)")
      @dealias_result.suit_check << "FNS#{stamp_types[:reply_cnt]}"
      return false
    end

    # check for two or more stamps with (A|AAAA)
    log("#{ip}: \tdouble stamp check (A|AAAA)")
    repeat_add(ip, [ip, ip, ip, ip])
    tasks = @prober.probe
    stamp_types = classify_stamps(tasks)

    if stamp_types[:reply_cnt] < 2
      # we do not have enough replies to have confidence
      log(err_message + 
          "(#{stamp_types[:no_reply]}/#{REPEAT} probes received no reply)")
      @dealias_result.suit_check << "FNR#{stamp_types[:reply_cnt]}"
      # tell them to reprobe because we saw replies to (A|AXXX)
      @dealias_result.overall = "UNKNOWN-REPROBE"
      return false
    elsif stamp_types.keys.length > 3 #(no_reply, reply_cnt, x_stamps)
      # more than one stamping behavior is seen
      log(err_message + "(more than one stamping behavior)")
      @dealias_result.suit_check << "FVS#{stamp_types[:reply_cnt]}"
      return false
    elsif stamp_types[:no_stamp] > 0
      log(err_mesage + "(no stamp)")
      @dealias_result.suit_check << "FNS#{stamp_types[:reply_cnt]}"
      return false
    elsif stamp_types[:one_stamp] > 0
      log(err_message + "(one stamp)")
      @dealias_result.suit_check << "F1S#{stamp_types[:reply_cnt]}"
      return false
    elsif stamp_types[:four_stamps] > 0
      log(message + " passed (4 stamps)")
      @dealias_result.suit_check << "P4S#{stamp_types[:reply_cnt]}"
      return true
    elsif stamp_types[:three_stamps] > 0
      log(message + " passed (3 stamps)")
      @dealias_result.suit_check << "P3S#{stamp_types[:reply_cnt]}"
      return true
    elsif stamp_types[:two_stamps] > 0
      log(message + " passed (2 stamps)")
      @dealias_result.suit_check << "P2S#{stamp_types[:reply_cnt]}"
      return true
    else
      # huh? how could we have possibly got here?
      log(message + "FATAL ERROR: invalid state")
      @dealias_result.suit_check << "XXX"
      @dealias_result.overall = "ERROR"
      return false
    end
  end

  def check_alias(ipa, ipb)
    message = "#{ipa},#{ipb}: dealias check"
    err_message = message + " failed "
    log(message)

    log("#{ipa}: \tdealias check (A|ABAB)")
    repeat_add(ipa, [ipa, ipb, ipa, ipb]);
    tasks_a = @prober.probe
    stamp_types_a = classify_stamps(tasks_a)

    log("#{ipb}: \tdealias check (B|BABA)")
    repeat_add(ipb, [ipb, ipa, ipb, ipa]);
    tasks_b = @prober.probe
    stamp_types_b = classify_stamps(tasks_b)

    a_valid = check_validity(stamp_types_a, ipa, @dealias_result.suit_check[0])
    b_valid = check_validity(stamp_types_b, ipb, @dealias_result.suit_check[1])

    if !a_valid || !b_valid
      if @dealias_result.alias_validity_check[0] == "F1S" &&
          @dealias_result.alias_validity_check[1] == "P2S"
        return ret_path_check(ipa, ipb)
      elsif @dealias_result.alias_validity_check[0] == "P2S" &&
          @dealias_result.alias_validity_check[1] == "F1S"
        return ret_path_check(ipb, ipa)
      else
        return false
      end
    end

    # we can merge these at this stage because we are sure that both a and b 
    # have ONLY one type of stamp and have at least two stamps
    stamp_types = classify_stamps(tasks_a | tasks_b)

    passed_cnt = stamp_types[:two_stamps] + stamp_types[:three_stamps] +
      stamp_types[:four_stamps]

    # be sure that we have a total of REPEAT stamps (50%) to base the analysis on
    if passed_cnt < REPEAT
      log(err_message + 
          "(#{passed_cnt} of #{REPEAT}" +
          " required probes with >=2 stamps)")
      @dealias_result.alias_check = "FIR"
      @dealias_result.overall = "UNKNOWN-REPROBE"
      return false
    end

    # these need to be split because we have to be sure that BOTH a and b
    # have replied with four stamps
    if stamp_types_a[:four_stamps] > 0 && stamp_types_b[:four_stamps] > 0
      log(message + " passed (4 stamps)")
      @dealias_result.alias_check = "P4S"
      @dealias_result.overall = "ALIAS"
      return true
    elsif (stamp_types_a[:two_stamps] > 0 && stamp_types_b[:four_stamps] > 0)||
        (stamp_types_a[:four_stamps]&& stamp_types_b[:two_stamps] > 0)
      log(message + " passed (2 stamps)")
      @dealias_result.alias_check = "P2S"
      if check_shared_clock((tasks_a | tasks_b), ipa, ipb)
        return check_distance_loop((tasks_a | tasks_b), ipa, ipb)
      else
        return false
      end
    elsif stamp_types[:three_stamps] > 0
      log(err_message + "(three stamps received)")
      @dealias_result.alias_check = "F3S"
      @dealias_result.overall = "ERROR"
      return false
    end
  end

  def classify_time_type(timestamp)
    if timestamp > 0 && timestamp < 86400000
      return :midnight_offset
    elsif timestamp < 0 || timestamp > 4294967296
      return :nonstandard
    elsif timestamp == 0
      return :zero
    else
      return :epoch
    end
  end

  def is_midnight_offset(tasks, stamp_types)
    mid_epoch_cnt = 0
    tasks.each do |task|
      stamp_one_type = nil
      stamp_two_type = nil
      result = task.result
      if result.reply_tsps_ts1
        stamp_one_type = classify_time_type(result.reply_tsps_ts1)
      end

      if result.reply_tsps_ts2
        stamp_two_type = classify_time_type(result.reply_tsps_ts2)
      end

      if stamp_one_type == :midnight_offset && stamp_two_type == :epoch
        mid_epoch_cnt += 1
      end
    end

    if mid_epoch_cnt == stamp_types[:two_stamps]
      return true
    else
      return false
    end
  end

  def check_shared_clock(tasks, ipa, ipb)
    message = "#{ipa},#{ipb}: shared clock check"
    err_message = message + " failed "
    log(message)

    passed_cnt = 0
    dec_ts = 0
    mid_epoch_cnt = 0

    stamp_types = classify_stamps(tasks)

    tasks.each do |task|
      result = task.result
      stamp_one_type = nil
      stamp_two_type = nil
      max_stamp = nil
      task_pass = true
      if result.reply_tsps_ts1
        max_stamp = result.reply_tsps_ts1
        stamp_one_type = classify_time_type(result.reply_tsps_ts1)
      end
      if result.reply_tsps_ts2
        stamp_two_type = classify_time_type(result.reply_tsps_ts2)
        if max_stamp > result.reply_tsps_ts2
          dec_ts += 1
        elsif max_stamp < result.reply_tsps_ts2
          max_stamp = result.reply_tsps_ts2
          task_pass = false
        end
      end
      if result.reply_tsps_ts3
        if max_stamp > result.reply_tsps_ts3
          dec_ts += 1
        elsif max_stamp < result.reply_tsps_ts3
          max_stamp = result.reply_tsps_ts3
          task_pass = false
        end
      end
      if result.reply_tsps_ts4
        if max_stamp > result.reply_tsps_ts4
          dec_ts += 1
        elsif max_stamp < result.reply_tsps_ts4
          max_stamp = result.reply_tsps_ts4
          task_pass = false
        end
      end

      mid_epoch_cnt += 1 if (stamp_one_type == :midnight_offset && 
        stamp_two_type == :epoch)

      passed_cnt += 1 if task_pass 
    end

    # check for decrementing timestamps
    if dec_ts > 0
      log(err_message + "(decrementing timestamp)")
      @dealias_result.shared_clk = "FDT#{dec_ts}"
      @dealias_result.overall = dec_ts == 0 ? "UNKNOWN-REPROBE" : "NOALIAS"
      return false
    end
          
    if mid_epoch_cnt == stamp_types[:two_stamps]
      log("#{ipa}: \tmidnight/epoch behavior check (A|BBBB)")
      repeat_add(ipa, [ipb, ipb, ipb, ipb])
      tasks = @prober.probe
      stamp_types = classify_stamps(tasks)
      ipa_offset = stamp_types[:two_stamps] > 0 && 
        is_midnight_offset(tasks, stamp_types)
        
      log("#{ipb}: \tmidnight/epoch behavior check (B|AAAA)")
      repeat_add(ipb, [ipa, ipa, ipa, ipa])
      tasks = @prober.probe
      stamp_types = classify_stamps(tasks)
      ipb_offset = stamp_types[:two_stamps] > 0 && 
        is_midnight_offset(tasks, stamp_types)

      if ipa_offset && ipb_offset
        log(message + "(midnight/epoch behavior)")
        @dealias_result.shared_clk = "PME"
        @dealias_result.overall = "ALIAS"
        return true
      end
    end

    shared_clk_pct = (passed_cnt/tasks.length.to_f)*100
    if shared_clk_pct >= 90
      log(message + " passed (#{shared_clk_pct}% shared clocks)")
      @dealias_result.shared_clk = "PSC"
      return true
    else
      log(err_message + "#{shared_clk_pct}% shared clocks (90% required)")
      @dealias_result.shared_clk = "F90"
      @dealias_result.overall = "UNKNOWN-NOALIAS"
      return false
    end
  end

  def check_distance_loop(tasks, ipa, ipb)
    message = "#{ipa},#{ipb}: distance/loop check"
    err_message = message + " failed "
    log(message)

    # check for loops
    # how?

    #log("#{ipa}: \tcheck reverse distance")
    repeat_add(ipa, nil);
    tasks = @prober.probe
    ipa_ttl = get_return_ttl(ipa, tasks)

    #log("#{ipb}: \tcheck reverse distance")
    repeat_add(ipb, nil);
    tasks = @prober.probe
    ipb_ttl = get_return_ttl(ipb, tasks)

    unless ipa_ttl && ipb_ttl
      @dealias_result.overall = "UNKNOWN-REPROBE"
      return false
    end

    if ipa_ttl != ipb_ttl
      log(err_message + "A(#{ipa_ttl}) and B(#{ipb_ttl}) not equidistant")
      @dealias_result.distance_loop = "FDI"
      @dealias_result.overall = "UNKNOWN-NOALIAS"
      return false
    end

    log(message + " passed (A(#{ipa_ttl}) == B=(#{ipb_ttl}))")
    @dealias_result.distance_loop = "PDI"
    @dealias_result.overall = "ALIAS"
    return true
  end

  def get_return_ttl(ip, tasks)
    message = "#{ip}: \testablishing return distance"
    err_message = message + " failed "
    log(message)

    ttl = nil
    noreply = 0
    tasks.each do |task|
      if task.result.responded?
        ttl = task.result.reply_ttl if ttl == nil
        if task.result.reply_ttl != ttl
          log(err_message + "reply ttl varies")
          @dealias_result.distance_loop = "FTV"
          return nil
        end
      else
        noreply += 1
      end
    end
    
    if noreply == REPEAT
      log(err_message + "no reply")
      @dealias_result.distance_loop = "FNR#{noreply}"
      return nil
    end

    return ttl
  end

  def classify_stamps(tasks)
    stamp_types = Hash.new(0)
    stamp_types[:no_reply] = 0 #ensure that there is always a key for this
    tasks.each do |task|
      stamp_types[count_stamps(task.result)] += 1
      stamp_types[:reply_cnt] += 1 if task.result.responded?
    end
    stamp_types
  end

  def count_stamps(result)
    return :no_reply if !result.responded?
    return :four_stamps if result.reply_tsps_ts4
    return :three_stamps if result.reply_tsps_ts3
    return :two_stamps if result.reply_tsps_ts2
    return :one_stamp if result.reply_tsps_ts1
    return :no_stamp
  end

  def check_validity(stamp_types, ip, suitresult)
    message = "#{ip}: \tvalidity check"
    err_message = message + " failed "
    log(message)

    if stamp_types[:reply_cnt] == 0
      log(err_message + "(no replies)")
      @dealias_result.alias_validity_check << "FNR"
      @dealias_result.overall = "UNKNOWN-REPROBE" unless @dealias_result.overall
      return false
    end

    if stamp_types.keys.length > 3
      log(err_message + "(multiple stamping behvaiors seen)")
      @dealias_result.alias_validity_check << "FVS"
      @dealias_result.overall = "INELIGIBLE" unless @dealias_result.overall
      return false
    end

    if suitresult =~ /P4S/ && (stamp_types[:two_stamps] > 0 ||
                               stamp_types[:three_stamps] > 0)
      log(err_message + "(was 4 stamps indicating reverse path)")
      @dealias_result.alias_validity_check << "FRP"
      @dealias_result.overall = "NOALIAS"
      return false
    end
    
    if stamp_types[:no_stamp] > 0
      log(err_message + "(no stamps)")
      @dealias_result.alias_validity_check << "FNS"
      @dealias_result.overall = "ERROR"
      return false
    end

    if stamp_types[:one_stamp] > 0 
      log(err_message + "(one stamp)")
      @dealias_result.alias_validity_check << "F1S"
      @dealias_result.overall = "UNKNOWN" unless @dealias_result.overall
      return false
    end

    if stamp_types[:two_stamps] > 0
      log(message + " passed (two stamps)")
      @dealias_result.alias_validity_check << "P2S"
      return true
    end

    if stamp_types[:three_stamps] > 0
      #leave this as a pass for the moment
      #it'll soon get weeded out
      log(message + " passed (three stamps)")
      @dealias_result.alias_validity_check << "P3S"
      return false
    end

    if stamp_types[:four_stamps] > 0
      log(message + " passed (four stamps)")
      @dealias_result.alias_validity_check << "P4S"
      return true
    end

    @dealias_result.alias_validity_check << "XXX"
    @dealias_result.overall = "ERROR"
  end

  #ip2 is the two stamper, ip1 is the one stamper
  def ret_path_check(ip1, ip2)
    message = "#{ip1},#{ip2}: return path check"
    err_message = message + " completed "
    log(message)

    log("#{ip1},#{ip2}: \tchecking for #{ip1} in the path to #{ip2} (A|BABA)")
    repeat_add(ip2, [ip1, ip2, ip1, ip2])
    tasks = @prober.probe

    stamp_types = classify_stamps(tasks)

    if stamp_types[:reply_cnt] == 0
      log(err_message + "(no reply)")
      @dealias_result.ret_path = "FNR"
      @dealias_result.overall = "UNKNOWN-REPROBE"
    end
    
    if stamp_types.keys.length > 3
      log(err_message + "(multiple stamping behvaiors seen)")
      @dealias_result.ret_path = "FVS"
      @dealias_result.overall = "INELIGIBLE"
    end
    
    if stamp_types[:no_stamp] > 0
      log(err_message + "(no stamps)")
      @dealias_result.ret_path = "FNS"
      @dealias_result.overall = "UNKNOWN-NOALIAS"
    end

    if stamp_types[:one_stamp] > 0 
      log(err_message + "(one stamp)")
      @dealias_result.ret_path "F1S"
      @dealias_result.overall = "ERROR"
    end

    if stamp_types[:two_stamps] > 0
      log(err_message + "(two stamps)")
      @dealias_result.ret_path = "F2S"
      @dealias_result.overall = "UNKNOWN-NOALIAS"
    end

    if stamp_types[:three_stamps] > 0
      log(err_message + "(three stamps)")
      @dealias_result.ret_path = "F3S"
      @dealias_result.overall = "NOALIAS"
    end

    if stamp_types[:four_stamps] > 0
      log(err_message + "(four stamps)")
      @dealias_result.ret_path = "F4S"
      @dealias_result.overall = "ERROR"
    end
    
    # once we get into this method, we've failed
    # we're just trying to figure out why
    return false

  end

  def failed(check)
    @failures[check] += 1;
  end

  def log(message)
    $stderr.puts message if $options.full
  end
  
end

#============================================================================

dealiasManager = TspsDealiasManager.new
dealiasManager.start
