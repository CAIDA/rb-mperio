#!/usr/bin/env ruby

#################################################################################
#
# Implements a traceroute algorithm using MperIO.
# 
# Algorithm ported from scamper (http://www.wand.net.nz/scamper)
#
#############################################################################

if $0 =~ /dev$/
  $: << "#{ENV['HOME']}/caida/rb-mperio/ext"
  $: << "#{ENV['HOME']}/caida/rb-mperio/lib"
else
  require 'rubygems'
end

require 'ostruct'
require 'optparse'

require 'mperio'

#never buffer stdout
$stdout.sync = true

$options = OpenStruct.new
$options.log_path = nil  # disable logging by default

$options.confidence = nil
$options.dport = nil
$options.firsthop = 1
$options.gaplimit = 5
$options.gapaction = :stop
$options.maxttl = 255
$options.loops = 1
$options.loopaction = 0
$options.probe_method = :icmp
$options.attempts = 2
$options.all_allocated = false
$options.not_time_exceeded = false
$options.spacing = 0

opts = OptionParser.new

opts.banner="usage: #{$0} [-?fv] [-n concurrency] [-s spacing] [-l logfile]\n"\
 + " " * $0.to_s.length + "        -p mperport -c candidatefile | IPa IPb"

opts.on("-p", "--mper-port=NUM", Integer,
	"mper control socket port (REQUIRED)") do |v|
  $options.mper_port = v
end

opts.on("-c", "--targets=PATH",
        "file with target address information") do |v|
  $options.target_path = v
end

opts.on("-n", "--concurrency=NUM", Integer,
        "max addresses to trace concurrently (default: unlimited)") do |v|
  $options.concurrency = v
end

opts.on("-f", "--full", TrueClass, "show full result output") do |v|
  $options.full = v
end

opts.on("-v", "--[no-]verbose", TrueClass,  "show detailed progress") do |v|
  $options.verbose = v
end

opts.on("-l", "--log=PATH", "mper command/result message log path") do |v|
  $options.log_path = v
end

opts.on("-c", "--confidence=NUM", Integer,
        "specifies that a hop should be probed to a specified confidence "\
        "level (95% or 99%) to be sure the trace has seen all interfaces "\
        "that will reply for that hop.") do |v|
  $options.confidence = v
end

opts.on("-d", "--dport=NUM", Integer,
        "specifies the base destination port value to use for UDP-based " \
        "and TCP-based traceroute methods. For ICMP-based methods, this " \
        "option has no effect.") do |v|
  $options.dport = v
end

opts.on("-f", "--firsthop=NUM", Integer, 
        "specifies the TTL or HLIM value to begin probing with (default: 1)"
        ) do |v|
  $options.firsthop = v
end

opts.on("-g", "--gaplimit=NUM", Integer, 
        "specifies the number of unresponsive hops permitted until a check " \
        "is made to see if the destination will respond. Zero is unlimited " \
        "(default: 5)") do |v|
  $options.gaplimit = v
end

opts.on("-G", "--gapaction=[stop|lastditch]", String,
        "specifies what should happen if the gaplimit condition is met.  A " \
        "value of 1 (default) means halt probing, while a value of 2 means " \
        "send last-ditch probes.") do |v|
  if v == "stop"
    $options.gapaction = :stop
  elsif v == "lastditch"
    $options.gapaction = :lastditch
  else
    raise OptionParser::ParseError
  end
end

opts.on("-m", "--maxttl=NUM", Integer, 
        "specifies the maximum TTL or HLIM value that will be probed.  By "\
        "default, there is no restriction, apart from the 255 hops that "\
        "the Internet protocols allow.") do |v|
  $options.maxttl = v
end

#no PMTUD as it is not supported by MperIO

opts.on("-l", "--loops=NUM", Integer,
        "specifies the maximum number of loops permitted until probing "\
        "stops.  By default, a value of one is used.  A value of zero "\
        "disables loop checking.") do |v|
  $options.loops = v
end

opts.on("-L", "--loopaction=NUM", Integer,
        "specifies the action to take when a loop is encountered.  A value "\
        "of 1 tells scamper to probe beyond the first loop in the trace."
        ) do |v|
  $options.loopaction = v
end

# no payload option as it isn't supported in MperIO -- right?

opts.on("-i", "--icmp", TrueClass,
        "probe with ICMP echo request (paris depends on mper) (default)") do |v|
  $options.probe_method = :icmp
end

opts.on("-u", "--udp", TrueClass,
        "probe with UDP (paris depends on mper)") do |v|
  $options.probe_method = :udp
end

opts.on("-t", "--tcp", TrueClass,
        "probe with TCP ACK") do |v|
  $options.probe_method = :tcp
end

opts.on("-a", "--attempts=NUM", Integer,
         "specifies the maximum number of attempts to obtain a response " \
         "per hop (default: 2)") do |v|
  $options.attempts = v
end

opts.on("-Q", "--all-allocated", TrueClass,
        "specifies that all allocated probes are sent, regardless of how "\
        "many responses have been received.") do |v|
  $options.all_allocated = v
end

# no sport as it is not supported by MperIO

opts.on("-S", "--src-addr=ADDR", String,
        "specifies the source address to use in probes.  The address "\
        "cannot be spoofed.") do |v|
  $options.src_addr = v
end

# no tos as it is not supported by MperIO (note, we stole -t for --tcp)
opts.on("-z" "--tos=HEX", String,
        "specifies the value to set in the IP ToS/DSCP + ECN byte.  By "\
        "default, this byte is set to zero.") do |v|
  $options.tos = v.hex
end

opts.on("-T", "--not-time-exceeded", TrueClass,
        "specifies that time exceeded messages from the destination do not "\
        "cause the trace to be defined as reaching the destination.") do |v|
  $options.not_time_exceeded = v
end

# userid is not supported by MperIO

opts.on("-w", "--timeout=NUM", Integer,
        "specifies how long to wait, in seconds, for a reply.  By default, "\
        "a value of 5 is used.") do |v|
  $options.timeout = v
end

opts.on("-W", "--wait-probe=NUM", Integer,
        "specifies the minimum time to wait, in 10s of milliseconds, "\
        "between sending consecutive probes.  By default the next probe is "\
        "sent as soon as possible.") do |v|
  $options.spacing = v
end

# gss-entry is not supported as we do not do doubletree

# lss-name is not supported as we do not do doubletree

opts.on_tail("-?", "--help", "show this message") do
  puts opts
  exit
end

begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!.to_s + "\n\n"
  $stderr.puts opts
  exit 1
end

unless $options.mper_port
  $stderr.puts "ERROR: missing mper port\n\n"
  $stderr.puts opts
  exit -1
end

unless $options.target_path || ARGV.length >= 1
  $stderr.puts "ERROR: target file path "\
    "or at least one address must be specified\n\n"
  $stderr.puts opts
  exit -1
end

#============================================================================

class TargetFile

  attr_reader :current_target

  def initialize(target_path)
    @target_path = target_path
    @target_io = File.open target_path
    @done = false
    advance
  end

  def advance
    if @done
      @current_target = nil
    else
      loop do
        line = @target_io.gets
        if line
          next if line =~ /^\#/ || line =~ /^\s*$/
          line.chomp!
          @current_target = line
          break
        else
          @done = true
          @current_target = nil
          break
        end
      end
    end
    return @current_target
  end

end

class ImmediateTargets

  def initialize(targets)
    @targets = targets
    advance
  end
  
  def validate_ip(ip)
    if ip =~ /^\d+\.\d+\.\d+\.\d+$/
      ip
    else
      $stderr.puts "ERROR: malformed target ip: \"#{ip}\""
      advance
    end
  end
  
  def current_target
    @current_target
  end
  
  def advance
    @current_target = @targets.shift
  end
end


#============================================================================

class Probe
  attr_accessor :id, :task, :dest, :ttl, :attempt, :result
  
  def initialize(dest, ttl, attempt)
    self.dest = dest
    self.ttl = ttl
    self.attempt = attempt #internal id for the task to use
  end

  def to_s
    "Probe #{id}: #{dest} TTL: #{ttl}"
  end
    
end

#============================================================================
class TraceManager
  
  def initialize

    # the list of tasks (must implement next_probe, receive_probe and taskid)
    @pending_tasks = []
    @next_task_id = 1

    @pending_probes = {}
    @next_probe_id = 1
    
    # initialize the list of addresses to probe
    if $options.target_path
      @targets = TargetFile.new $options.target_path
    else
      @targets = ImmediateTargets.new ARGV
    end
    
    # initialize the mper connection
    begin
      @mperio = MperIO.new $options.mper_port, $options.log_path
      @mperio.delegate = self
    rescue
      $stderr.puts "Failed to connect to mper on port " +
        "#{$options.mper_port}. Is mper running? Is the log path valid?"
      exit -1
    end
    
  end
  
  def start
    @mperio.start
  end
  
  def stop
    @mperio.stop
  end
  
  def get_next_task_id
    id = @next_task_id
    @next_task_id += 1
    return id
  end
  
  def get_next_probe_id
    id = @next_probe_id
    @next_probe_id += 1
    return id
  end
  
  ####
  # used by the TraceTask objects to queue a probe that they want sent
  #
  def queue_probe(task, probe)
    probe.id = get_next_probe_id()
    probe.task = task
    # if $options.verbose
    #  printf "probing (%s|%s) @ %d\n", probe.dest, tsps_ips_s, probe.id 
    # end
    @pending_probes[probe.id] = probe

    case $options.probe_method
      when :icmp
      @mperio.ping_icmp(probe.id, probe.dest, :ttl, probe.ttl,
                        :src_addr, $options.src_addr,
                        :tos, $options.tos,
                        :timeout, $options.timeout,
                        :spacing, $options.spacing)
      when :udp
      @mperio.ping_udp(probe.id, probe.dest, :ttl, probe.ttl,
                        :src_addr, $options.src_addr,
                        :tos, $options.tos,
                        :timeout, $options.timeout,
                        :spacing, $options.spacing)

    when :tcp
      @mperio.ping_tcp(probe.id, probe.dest, :ttl, probe.ttl,
                       :src_addr, $options.src_addr,
                       :tos, $options.tos,
                       :timeout, $options.timeout,
                       :spacing, $options.spacing)
      
      else fail "INTERNAL ERROR: invalid probing method"
    end
  end
  
  ####
  # used by this object to find the probe object for the given reply
  def match_result(result)
    probe = @pending_probes.delete result.reqnum
    return probe
  end
  
  def fill_task_queue
    while (target = @targets.current_target) != nil
      if $options.concurrency && @pending_tasks.length >= $options.concurrency
        @reached_concurrency = true
        break
      end
      task = TraceTask.new(get_next_task_id(), target)
      @pending_tasks.push task
      @targets.advance
    end
  end
  
  def mperio_on_more
    # fill the task list
    fill_task_queue()
    
    # send the next probe - whatever it may be
    probe_next_task()

    if @pending_tasks.length == 0 && @pending_probes.length == 0
      stop()
    end
  end

  def probe_next_task
    task_cnt = @pending_tasks.length

    # we allow ourselves at most one pass through the list
    # if no tasks can muster up a probe to send after one
    # pass, then we're either done, or they are all waiting
    # for responses, we might as well wait too.
    task_cnt.times do |i|
      # remove the next task from the head of the list
      task = @pending_tasks.shift

      # the list is empty - all tasks are complete
      unless task
        break
      end
      
      # no need to continue probing it
      if task.is_complete
        # add another task (if there are any remaining)
        fill_task_queue()
        # we haven't managed to send a probe yet, keep trying
        probe_next_task()
        # we either sent a probe, or we completed a full cycle,
        # either way, we're not going to look for any more probes
        break
      else
        # the task is still active
        # append it to the 'tail' of the list
        @pending_tasks.push task
        
        # ask for the next probe it wants to send
        probe =  task.next_probe
        if probe
          # it still has a probe that it would like to send
          queue_probe(task, probe)
          # at this point, we have definitely sent a probe
          # no more more
          @more = false
          # the probe is sent, lets not send any more until mper asks us to
          break
        else
          # we didn't manage to send a probe, so let's keep that in mind
          @more = true
        end
      end
    end
  end
  
  def mperio_on_data(result)
    #printf "mperio_on_data: %p\n", result #if $options.verbose

    probe = match_result(result)

    if probe
      probe.result = result
      probe.task.receive_probe(probe)
    else
      $stderr.puts "ignoring duplicate reply received from " +
        "#{result.probe_dest} for probe #{result.reqnum}"
      # exit -1
    end

    fill_task_queue()

    if @more
      mperio_on_more()
    end
  end


  def mperio_on_error(reqnum, message)
    $stderr.printf "mperio_on_error: reqnum=%d msg=%s\n", reqnum, message
    @mperio.stop
    exit 1
  end


  def mperio_on_send_error(reqnum, message)
    $stderr.printf "mperio_on_send_error: reqnum=%d msg=%s\n", reqnum, message
    @pending_tasks.remove reqnum
    @mperio.suspend if @pending_tasks.length == 0 && @queued_tasks.length == 0
  end


  def mperio_service_failure(message)
    $stderr.printf "mperio_service_failure: %s\n", message
    @mperio.stop
    exit 1
  end

end

class TraceResult
  
  attr_reader :target
  attr_accessor :hops, :stop_reason
  
  def initialize(target)
    @target = target
    @hops = [] # hash of hops TTL => hop
    allocate_hop($options.firsthop)
  end

  def allocate_hop(ttl)
    hop = Hop.new(ttl)
    @hops << hop
    return hop
  end

  def hop_at_ttl(ttl)
    return @hops[ttl-1]
  end

  def to_s
    str = "traceroute to #{@target}\n"
    @hops.each do |hop|
      str += hop.to_s
    end
    str += "stop reason: #{@stop_reason}\n"
  end  

end

class Hop

  attr_accessor :ttl, :results, :responsive

  def initialize(ttl)
    @ttl = ttl
    @results = []
    @responsive = true
  end

  def to_s
    str = @ttl.to_s
    @results.each do |result|
      if result.responded?
        str += sprintf("\t%s\t\%s ms\n", result.reply_src, rtt(result))
      else
        str += sprintf("\t*\n")
      end
    end
    return str
  end

  def rtt(result)
    return "-" if !result.responded?
    tx = Time.at(result.tx_sec, result.tx_usec)
    rx = Time.at(result.rx_sec, result.rx_usec)
    (rx-tx) * 1000
  end
  
end

class TraceTask

  attr_reader :taskid, :is_complete

  def initialize(taskid, target)
    @taskid = taskid
    @target = target

    log("#{@target}: trace starting");

    @trace_result = TraceResult.new(@target)
    @is_complete = false

    @ttl        = $options.firsthop

    @attempt    = 0
    @n          = 2 # used for confidence, assume two initially
    @loopc      = 0
    @iloopc     = 0

    @replies = []
    @probe_queue = []
    @pending_probes = 0
    
    @interfaces = []

    # i think that for the moment we can do all of the probing from this
    # one task.
    # reintroduce later if we need sub-tasks
    # @current_state = TspsDealiasSuitabilityTask.new(target, 
    #                                               @dealias_result)
  end
  
  def add_interface(interface)
    @interfaces << interface unless @interfaces.contains(interface)
    @n += 1
  end
  
  def to_s
    "Task: #{@taskid} To: #{@target} TTL: #{@ttl}"
  end

  #def current_state
  #  return nil unless @current_state
  #  if @current_state.is_complete
  #    @current_state = @current_state.next_state
  #  end
  #  return @current_state
  #end

  # note to self, methods are called in this order:
  # is_complete ? nil : next_probe
  # so next_probe is only called if is_complete returns false
  # is_complete is ALWAYS called before next_probe

  def next_probe
    #current_state().next_probe
    # what is our next probe?
    if @probe_queue.length == 0 && @pending_probes == 0
      @attempt += 1
      @probe_queue << Probe.new(@target, @ttl, @attempt)
    end
    probe = @probe_queue.shift
    @pending_probes += 1 if probe
    return probe
  end

  def receive_probe(probe)
    #current_state().receive_probe(probe)
    # receive the probe!
    unless probe
      return
    end

    @pending_probes -= 1

    if !probe.result.responded?
      receive_timeout_probe(probe)
    elsif probe.result.icmp_reply?
      receive_icmp_probe(probe)
    elsif probe.result.tcp_reply?
      receive_tcp_probe(probe)
    else
      $stderr.puts "FATAL ERROR: unknown reply type"
    end
  end

  def receive_icmp_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    # to make the port from scamper easier, we assume that we're not
    # going to probe any more as the default position of this method
    @is_complete = true

    # if this reply is not for the current ttl (i.e. a late reply),
    # check if we can stop now
    if(result.probe_ttl != @ttl)
      reason = stop_reason(@trace_result, result)
      if(reason != :stop_none)
        @trace_result.stop_reason = reason
        return
      end
    end

    ##
    # the rest of the code in this function deals with the fact this is a
    # reply for the current working hop.
    #
    # check if we are to send all allotted probes to the target
    ##
    if($options.all_allocated)
      if($options.confidence)
        $stderr.puts "FATAL ERROR: confidence and all_allocated cannot be "\
          "used simulaneously"
      end
      
      ##
      # if we get an out of order reply, then we go back to waiting for
      # the one we just probed for
      ##
      if(probe.attempt != @attempt)
        @is_complete = false
        return
      end

      ##
      # this response is for the last probe sent.  if there are still
      # probes to send for this hop, then send the next one
      ##
      if(@attempt < $options.attempts)
        @is_complete = false
        return
      end

    elsif($options.confidence)
      ##
      # record details of the interface, if its details are not
      # currently held
      ##
      add_interface(result.reply_src)

      if(@n <= CONFIDENCE_MAX_N)
        ##
        # if we get an out of order reply, then we go back to waiting for
        # the one we just probed for
        ##
        if(probe.attempt != @attempt)
          @is_complete = false
          return
        end

        ##
        # this response is for the last probe sent.  if there are still
        # probes to send for this hop, then send the next one
        ##
        if(@attempt < k(@n))
          @is_complete = false
          return
        end

        ##
        # if we get to here, the confidence for this hop is done,
        # reset the state we keep about that stuff
        ##
        @n = 2
        @interfaces = []
      end

      @attempt = 1
    end

    ##
    # if we're in a mode where we only care about the first response to
    # a probe, then check it now.  the else block below handles the case
    # where we want a larger number of responses from a hop.
    ##
    if(!$options.confidence && !$options.all_allocated)
      #check to see if we have a stop reason from the ICMP response
      reason = stop_reason(@trace_result, result)
      if(reason != :stop_none)
        @trace_result.stop_reason = reason
        return
      end
    else
      # check all hop records for a reason to halt the trace
      @trace_result.hops.each do |hop|
        hop.results.each do |tr|
          reason = stop_reason(@trace_result, tr)
          if(reason != :stop_none)
            @trace_result.stop_reason = reason
            return
          end
        end
      end
    end
    
    # check if we've reached the hoplimit
    if(@trace_result.hops.length == 255 || 
       @trace_result.hops.length == $options.hoplimit)
      @trace_result.stop_reason = :stop_hoplimit
      return
    end

    #move on to the next ttl

    @attempt = 0
    @ttl += 1
    @trace_result.allocate_hop(@ttl)
    
    @is_complete = false
    return
    
  end

  def receive_tcp_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    # to make the port from scamper easier, we assume that we're not
    # going to probe any more as the default position of this method
    @is_complete = true

    # if we are sending all allotted probes to the target
    if($options.all_attempts)
      if(probe.attempts != @attempt)
        @is_complete = false
        return
      end
    elsif($options.confidence)
      # record details of the interface
      add_interface(result.reply_src)

      if(@n <= CONFIDENCE_MAX_N && @attempt < k(@n))
        @is_completed = false
        return
      end
    end

    @trace_reason = :stop_completed
    return
  end

  def receive_timeout_probe(probe)
    result = probe.result

    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    if(@attempt == $options.attempts)
      @is_complete = true
      hop.responsive = false
      # all probes for this hop have now been sent

      # scamper does a check to see if any of the other responses can be
      # used for a stop reason. this shouldnt apply for us, but let's do
      # it anyway.
      @trace_result.hops.each do |hop|
        hop.results.each do |tr|
          reason = stop_reason(@trace_result, tr)
          if(reason != :stop_none)
            @trace_result.stop_reason = reason
            return
          end
        end
      end
      
      # check if we've reached the hoplimit
      if(@trace_result.hops.length == 255 || 
         @trace_result.hops.length == $options.hoplimit)
        @trace_result.stop_reason = :stop_hoplimit
        return
      end

      # see if a non-response for this hop brings us to the gap limit
      if(@trace_result.hops.length >= $options.gaplimit)
        # start at the current ttl -1 and go back gaplimit -1 hops
        # check if all of these hops are unresponsive
        deadpath = true
        (@ttl-1).downto(@ttl-($options.gaplimit-1)) do |i|
          hop = @trace_result.hop_at_ttl(i)
          if hop && hop.responsive
            deadpath = false
            break
          end
        end

        # add lastditch mode stuff in here
        if deadpath
          @trace_result.stop_reason = :gaplimit
          return
        end

      end

      @attempt = 0
      @ttl += 1
      @trace_result.allocate_hop(@ttl)
      @is_complete = false
    end
    
  end

  def is_complete
    puts @trace_result if @is_complete
    return @is_complete
    #if current_state() == nil
    #  log("#{@ipa},#{@ipb}: dealiasing complete");
    #  puts @dealias_result
    #  true   
    #else
    #  false
    #end
  end

end #TraceTask

#################################################################################
# STATIC HELPER METHODS
#################################################################################

$k = [
      [   0,   0 ], [   0,   0 ], [   6,   8 ], [  11,  15 ], [  16,  21 ],
      [  21,  28 ], [  27,  36 ], [  33,  43 ], [  38,  51 ], [  44,  58 ],
      [  51,  66 ], [  57,  74 ], [  63,  82 ], [  70,  90 ], [  76,  98 ],
      [  83, 106 ], [  90, 115 ], [  96, 123 ], [ 103, 132 ], [ 110, 140 ],
      [ 117, 149 ], [ 124, 157 ], [ 131, 166 ], [ 138, 175 ], [ 145, 183 ],
      [ 152, 192 ], [ 159, 201 ], [ 167, 210 ], [ 174, 219 ], [ 181, 228 ],
      [ 189, 237 ], [ 196, 246 ], [ 203, 255 ], [ 211, 264 ], [ 218, 273 ],
      [ 226, 282 ], [ 233, 291 ], [ 241, 300 ], [ 248, 309 ], [ 256, 319 ],
      [ 264, 328 ], [ 271, 337 ], [ 279, 347 ], [ 287, 356 ], [ 294, 365 ],
      [ 302, 375 ], [ 310, 384 ], [ 318, 393 ], [ 326, 403 ], [ 333, 412 ],
      [ 341, 422 ], [ 349, 431 ], [ 357, 441 ], [ 365, 450 ], [ 373, 460 ],
      [ 381, 470 ], [ 389, 479 ], [ 397, 489 ], [ 405, 499 ], [ 413, 508 ],
      [ 421, 518 ], [ 429, 528 ], [ 437, 537 ], [ 445, 547 ], [ 453, 557 ],
      [ 462, 566 ], [ 470, 576 ], [ 478, 586 ], [ 486, 596 ], [ 494, 606 ],
      [ 502, 616 ], [ 511, 625 ], [ 519, 635 ], [ 527, 645 ], [ 535, 655 ],
      [ 544, 665 ], [ 552, 675 ], [ 560, 685 ], [ 569, 695 ], [ 577, 705 ],
      [ 585, 715 ], [ 594, 725 ], [ 602, 735 ], [ 610, 745 ], [ 619, 755 ],
      [ 627, 765 ], [ 635, 775 ], [ 644, 785 ], [ 652, 795 ], [ 661, 805 ],
      [ 669, 815 ], [ 678, 825 ], [ 686, 835 ], [ 695, 845 ], [ 703, 855 ],
      [ 712, 866 ], [ 720, 876 ], [ 729, 886 ], [ 737, 896 ], [ 746, 906 ],
    ]

CONFIDENCE_MAX_N = $k.length

def k(n, confidence)
  return $k[n][confidence]
end

def log(message)
  $stderr.puts message if $options.full
end

###
# decide if this result is a good enough reason to stop
def stop_reason(trace_result, result)
  
   ##
   # the message received is an ICMP port unreachable -- something that
   # the destination should have sent.  make sure the port unreachable
   # message makes sense based on the traceroute type.
   ##
  
  if(is_icmp_unreach_port(result) && (is_method(:udp) || is_method(:tcp)))
    reason = :stop_completed
  elsif(is_icmp_unreach(result))
    reason = :stop_unreach
  elsif(is_icmp_echo_reply(result))
    ##
    # the message received is an ICMP echo reply -- something that only
    # makes sense to include as part of the traceroute if the traceroute
    # is using echo requests.
    ##
    if(is_method(:icmp))
      reason = :stop_completed
    else
      reason = :stop_none
    end
  elsif($options.loops != 0 && is_loop(trace_result, result)) 
    # checked for and found loop condition
    reason = :stop_loop
  elsif(is_icmp_ttl_exp(result) && $options.not_time_exceeded == false &&
        is_target(trace_result, result))
    ##
    # if an ICMP TTL expired message is received from an IP address
    # matching the destination being probed, and the traceroute is
    # to stop when this occurs, then stop.
    ##
    reason = :stop_completed
  elsif(is_method(:tcp) && result.tcp_reply?)
    reason = :stop_completed
  else
    reason = :stop_none
  end
    
  return reason
end

def is_method(method)
  return $options.probe_method == method
end

def is_icmp_ttl_exp(result)
  (!is_method(:tcp) || result.reply_icmp_type == 11)
end

def is_icmp_ttl_exp_trans(result)
  (!is_method(:tcp) && 
   result.reply_icmp_type == 11 && result.reply_icmp_code == 0)
end

#def is_icmp_ptb(result)
#  ($options.method != :tcp &&
#   result.reply_icmp_type == 3 && result.reply_icmp_code == 4)
#end

def is_icmp_unreach(result)
  (!is_method(:tcp) && result.reply_icmp_type == 3)
end

def is_icmp_unreach_port(result)
  (!is_method(:tcp) &&
   result.reply_icmp_type == 3 && result.reply_icmp_code == 3)
 end

def is_icmp_echo_reply(result)
  (!is_method(:tcp) && result.reply_icmp_type == 0)
end

def is_target(trace_result, result)
  (trace_result.target == result.reply_src)
end

def is_loop(trace_result, result)
  #implement!
  return false
end

#################################################################################

traceManager = TraceManager.new
traceManager.start
