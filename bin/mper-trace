#!/usr/bin/env ruby

#################################################################################
#
# Implements a traceroute algorithm using MperIO.
# 
# Algorithm ported from scamper (http://www.wand.net.nz/scamper)
#
#############################################################################

if $0 =~ /dev$/
  $: << "#{ENV['HOME']}/caida/rb-mperio/ext"
  $: << "#{ENV['HOME']}/caida/rb-mperio/lib"
else
  require 'rubygems'
end

require 'ostruct'
require 'optparse'

require 'mperio'

#never buffer stdout
$stdout.sync = true

$options = OpenStruct.new
$options.log_path = nil  # disable logging by default

$options.confidence = nil
$options.dport = nil
$options.firsthop = 1
$options.gaplimit = 5
$options.gapaction = :stop
$options.hoplimit = 255
$options.loops = 1
$options.loopaction = 0
$options.probe_method = :icmp
$options.attempts = 2
$options.all_allocated = false
$options.not_time_exceeded = false
$options.spacing = 0
$options.concurrency = nil
$options.recordroute = 0

opts = OptionParser.new

opts.banner="usage: #{$0} [-?fv] [-n concurrency] [-s spacing] [-l logfile]\n"\
 + " " * $0.to_s.length + "        -p mperport -c candidatefile | IPa IPb"

opts.on("-a", "--attempts=NUM", Integer,
         "specifies the maximum number of attempts to obtain a response " \
         "per hop (default: 2)") do |v|
  $options.attempts = v
end

opts.on("-b", "--log=PATH", "mper command/result message log path") do |v|
  $options.log_path = v
end

opts.on("-c", "--confidence=NUM", Integer,
        "specifies that a hop should be probed to a specified confidence "\
        "level (95% or 99%) to be sure the trace has seen all interfaces "\
        "that will reply for that hop.") do |v|
  case v
  when 95:
    $options.confidene = 0
  when 99:
    $options.confidence = 1
  else
    raise OptionParser::ParseError
  end
end

opts.on("-d", "--dport=NUM", Integer,
        "specifies the base destination port value to use for UDP-based " \
        "and TCP-based traceroute methods. For ICMP-based methods, this " \
        "option has no effect.") do |v|
  $options.dport = v
end

opts.on("-D", "--mper-port=NUM", Integer,
	"mper control socket port (REQUIRED)") do |v|
  $options.mper_port = v
end

opts.on("-f", "--firsthop=NUM", Integer, 
        "specifies the TTL or HLIM value to begin probing with (default: 1)"
        ) do |v|
  $options.firsthop = v
end

opts.on("-g", "--gaplimit=NUM", Integer, 
        "specifies the number of unresponsive hops permitted until a check " \
        "is made to see if the destination will respond. Zero is unlimited " \
        "(default: 5)") do |v|
  $options.gaplimit = v
end

opts.on("-G", "--gapaction=STR", String,
        "specifies what should happen if the gaplimit condition is met. " \
        "stop: halt probing, lastditch: send last-ditch probes.") do |v|
  if v == "stop"
    $options.gapaction = :stop
  elsif v == "lastditch"
    $options.gapaction = :lastditch
  else
    raise OptionParser::ParseError
  end
end

opts.on("-i", "--targets=PATH",
        "file with target address information") do |v|
  $options.target_path = v
end

opts.on("-l", "--loops=NUM", Integer,
        "a value of 1 enables loop checking (default), whereas a value of " \
        "0 disables loop checking.") do |v|
  if v == 1 || v == 0
    $options.loops = v
  else
    raise OptionParser::ParseError
  end
end

opts.on("-L", "--loopaction=NUM", Integer,
        "specifies the number of 'adjacent interface' loops to allow. " \
        "a value of 0 means that the first set of identical adjacent " \
        "interfaces will cause the trace to halt, 1 the second set (i.e. "\
        "allow 1 set)"
        ) do |v|
  $options.loopaction = v
end

opts.on("-m", "--maxttl=NUM", Integer, 
        "specifies the maximum TTL or HLIM value that will be probed.  By "\
        "default, there is no restriction, apart from the 255 hops that "\
        "the Internet protocols allow.") do |v|
  $options.hoplimit = v
end

opts.on("-n", "--concurrency=NUM", Integer,
        "max addresses to trace concurrently (default: unlimited - be careful,"\
        " this will try and trace all interfaces simultaneously)") do |v|
  $options.concurrency = v
end

opts.on("-P", "--method=STR", String,
        "icmp: probe with ICMP echo request (paris depends on mper) (default), "\
        "udp: probe with UDP packets, or tcp: TCP ACK") do |v|
  $stderr.puts "v: #{v}"
  case v
  when "icmp":
      $options.probe_method = :icmp
  when "udp":
      $options.probe_method = :udp
  when "tcp":
      $options.probe_method = :tcp
  else
    raise OptionParser::ParseError
  end
end

opts.on("-Q", "--all-allocated", TrueClass,
        "specifies that all allocated probes are sent, regardless of how "\
        "many responses have been received.") do |v|
  $options.all_allocated = v
end

opts.on("-R", "--recordroute", TrueClass,
        "enable the record route IP option (default: off)") do |v|
  $options.rr = 1
end

opts.on("-S", "--src-addr=ADDR", String,
        "specifies the source address to use in probes.  The address "\
        "cannot be spoofed.") do |v|
  $options.src_addr = v
end

opts.on("-t", "--tsps=STR", String,
        "addresses to use for the prespecified timestamp IP option. "\
        "format: ip1[,ip2[,ip3[,ip4]]]") do |v|
  $options.tsps = v.split(",")
end

opts.on("-T", "--not-time-exceeded", TrueClass,
        "specifies that time exceeded messages from the destination do not "\
        "cause the trace to be defined as reaching the destination.") do |v|
  $options.not_time_exceeded = v
end

opts.on("-v", "--[no-]verbose", TrueClass,  "show detailed progress") do |v|
  $options.verbose = v
end

opts.on("-V", "--full", TrueClass, "show full result output") do |v|
  $options.full = v
end

opts.on("-w", "--timeout=NUM", Integer,
        "specifies how long to wait, in seconds, for a reply.  By default, "\
        "a value of 5 is used.") do |v|
  $options.timeout = v
end

opts.on("-W", "--wait-probe=NUM", Integer,
        "specifies the minimum time to wait, in 10s of milliseconds, "\
        "between sending consecutive probes.  By default the next probe is "\
        "sent as soon as possible.") do |v|
  $options.spacing = v
end

opts.on("-z", "--tos=HEX", String,
        "specifies the value to set in the IP ToS/DSCP + ECN byte.  By "\
        "default, this byte is set to zero.") do |v|
  $options.tos = v.hex
end

opts.on_tail("-?", "--help", "show this message") do
  puts opts
  exit
end

begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!.to_s + "\n\n"
  $stderr.puts opts
  exit 1
end

unless $options.mper_port
  $stderr.puts "ERROR: missing mper port\n\n"
  $stderr.puts opts
  exit -1
end

unless $options.target_path || ARGV.length >= 1
  $stderr.puts "ERROR: target file path "\
    "or at least one address must be specified\n\n"
  $stderr.puts opts
  exit -1
end

if $options.confidence && $options.all_allocated
  $stderr.puts "ERROR: only one of 'confidence' or 'all-allocated' may " \
  "be specified at once"
  $stderr.puts opts
  exit -1
end

if $options.hoplimit && $options.hoplimit < $options.firsthop
  $stderr.puts "ERROR: firsthop is set further than the hoplimit"
  $stderr.puts opts
  exit -1
end

if $options.tsps && $options.rr
  $stderr.puts "ERROR: only one of tsps and record route may be specified " \
  "at once"
  $stderr.puts opts
  exit -1
end

#============================================================================

class TargetFile

  attr_reader :current_target

  def initialize(target_path)
    @target_path = target_path
    @target_io = File.open target_path
    @done = false
    advance
  end

  def advance
    if @done
      @current_target = nil
    else
      loop do
        line = @target_io.gets
        if line
          next if line =~ /^\#/ || line =~ /^\s*$/
          line.chomp!
          @current_target = line
          break
        else
          @done = true
          @current_target = nil
          break
        end
      end
    end
    return @current_target
  end

end

class ImmediateTargets

  def initialize(targets)
    @targets = targets
    advance
  end
  
  def validate_ip(ip)
    if ip =~ /^\d+\.\d+\.\d+\.\d+$/
      ip
    else
      $stderr.puts "ERROR: malformed target ip: \"#{ip}\""
      advance
    end
  end
  
  def current_target
    @current_target
  end
  
  def advance
    @current_target = @targets.shift
  end
end


#============================================================================

class Probe
  attr_accessor :id, :task, :dest, :ttl, :attempt, :result
  
  def initialize(dest, ttl, attempt)
    self.dest = dest
    self.ttl = ttl
    self.attempt = attempt #internal id for the task to use
  end

  def to_s
    "Probe #{id}: #{dest} TTL: #{ttl}"
  end
    
end

#============================================================================
class TraceManager
  
  def initialize

    # the list of tasks (must implement next_probe, receive_probe and taskid)
    @pending_tasks = []
    @next_task_id = 1

    @pending_probes = {}
    @next_probe_id = 1
    
    # initialize the list of addresses to probe
    if $options.target_path
      @targets = TargetFile.new $options.target_path
    else
      @targets = ImmediateTargets.new ARGV
    end
    
    # initialize the mper connection
    begin
      @mperio = MperIO.new $options.mper_port, $options.log_path
      @mperio.delegate = self
    rescue
      $stderr.puts "Failed to connect to mper on port " +
        "#{$options.mper_port}. Is mper running? Is the log path valid?"
      exit -1
    end
    
  end
  
  def start
    @mperio.start
  end
  
  def stop
    @mperio.stop
  end
  
  def get_next_task_id
    id = @next_task_id
    @next_task_id += 1
    return id
  end
  
  def get_next_probe_id
    id = @next_probe_id
    @next_probe_id += 1
    return id
  end
  
  ####
  # used by the TraceTask objects to queue a probe that they want sent
  #
  def queue_probe(task, probe)
    probe.id = get_next_probe_id()
    probe.task = task
    # if $options.verbose
    #  printf "probing (%s|%s) @ %d\n", probe.dest, tsps_ips_s, probe.id 
    # end
    @pending_probes[probe.id] = probe

    case $options.probe_method
      when :icmp
      @mperio.ping_icmp(probe.id, probe.dest, :ttl, probe.ttl,
                        :src_addr, $options.src_addr,
                        :tos, $options.tos,
                        :timeout, $options.timeout,
                        :spacing, $options.spacing,
                        :tsps, $options.tsps,
                        :rr, $options.rr)
      when :udp
      @mperio.ping_udp(probe.id, probe.dest, :ttl, probe.ttl,
                       :dport, $options.dport,
                       :src_addr, $options.src_addr,
                       :tos, $options.tos,
                       :timeout, $options.timeout,
                       :spacing, $options.spacing)

    when :tcp
      @mperio.ping_tcp(probe.id, probe.dest, :ttl, probe.ttl,
                       :dport, $options.dport,
                       :src_addr, $options.src_addr,
                       :tos, $options.tos,
                       :timeout, $options.timeout,
                       :spacing, $options.spacing)
      
      else fail "INTERNAL ERROR: invalid probing method"
    end
  end
  
  ####
  # used by this object to find the probe object for the given reply
  def match_result(result)
    probe = @pending_probes.delete result.reqnum
    return probe
  end
  
  def fill_task_queue
    while (target = @targets.current_target) != nil
      if $options.concurrency && @pending_tasks.length >= $options.concurrency
        @reached_concurrency = true
        break
      end
      task = TraceTask.new(get_next_task_id(), target)
      @pending_tasks.push task
      @targets.advance
    end
  end
  
  def mperio_on_more
    # fill the task list
    fill_task_queue()
    
    # send the next probe - whatever it may be
    probe_next_task()

    if @pending_tasks.length == 0 && @pending_probes.length == 0
      stop()
    end
  end

  def probe_next_task
    task_cnt = @pending_tasks.length

    # we allow ourselves at most one pass through the list
    # if no tasks can muster up a probe to send after one
    # pass, then we're either done, or they are all waiting
    # for responses, we might as well wait too.
    task_cnt.times do |i|
      # remove the next task from the head of the list
      task = @pending_tasks.shift

      # the list is empty - all tasks are complete
      unless task
        break
      end
      
      # no need to continue probing it
      if task.is_complete
        # add another task (if there are any remaining)
        fill_task_queue()
        # we haven't managed to send a probe yet, keep trying
        probe_next_task()
        # we either sent a probe, or we completed a full cycle,
        # either way, we're not going to look for any more probes
        break
      else
        # the task is still active
        # append it to the 'tail' of the list
        @pending_tasks.push task
        
        # ask for the next probe it wants to send
        probe =  task.next_probe
        if probe
          # it still has a probe that it would like to send
          queue_probe(task, probe)
          # at this point, we have definitely sent a probe
          # no more more
          @more = false
          # the probe is sent, lets not send any more until mper asks us to
          break
        else
          # we didn't manage to send a probe, so let's keep that in mind
          @more = true
        end
      end
    end
  end
  
  def mperio_on_data(result)
    #printf "mperio_on_data: %p\n", result #if $options.verbose

    probe = match_result(result)

    if probe
      probe.result = result
      probe.task.receive_probe(probe)
    else
      $stderr.puts "ignoring duplicate reply received from " +
        "#{result.probe_dest} for probe #{result.reqnum}"
      # exit -1
    end

    fill_task_queue()

    if @more
      mperio_on_more()
    end
  end


  def mperio_on_error(reqnum, message)
    $stderr.printf "mperio_on_error: reqnum=%d msg=%s\n", reqnum, message
    @mperio.stop
    exit 1
  end


  def mperio_on_send_error(reqnum, message)
    $stderr.printf "mperio_on_send_error: reqnum=%d msg=%s\n", reqnum, message
    @pending_tasks.remove reqnum
    @mperio.suspend if @pending_tasks.length == 0 && @queued_tasks.length == 0
  end


  def mperio_service_failure(message)
    $stderr.printf "mperio_service_failure: %s\n", message
    @mperio.stop
    exit 1
  end

end

class TraceResult
  
  attr_reader :target
  attr_accessor :hops, :stop_reason  
  def initialize(target)
    @target = target
    @hops = [] # hash of hops TTL => hop
    allocate_hop($options.firsthop)
  end

  def allocate_hop(ttl)
    hop = Hop.new(ttl)
    @hops[ttl-1] = hop
    return hop
  end

  def hop_at_ttl(ttl)
    return @hops[ttl-1]
  end

  def to_s
    str = "traceroute to #{@target}\n"
    @hops.each do |hop|
      next unless hop
      str += hop.to_s
    end
    str += "stop reason: #{@stop_reason}\n"
  end  

end

class Hop

  attr_accessor :ttl, :results, :responsive

  def initialize(ttl)
    @ttl = ttl
    @results = []
    @responsive = true
  end

  def to_s
    str = @ttl.to_s
    @results.each do |result|
      if result.responded?
        str += sprintf("\t%s\t\%s ms", result.reply_src, rtt(result))
        if $options.full
          if $options.tsps
            str += sprintf("\t%s", build_tsps_str(result))
          elsif $options.rr
            str += sprintf("\t%s", result.reply_rr)
          end
        end
        str += "\n"
      else
        str += sprintf("\t*\n")
      end
    end
    return str
  end

  def build_tsps_str(result)
    str = ""
    str += sprintf("%s=%d", result.reply_tsps_ip1, result.reply_tsps_ts1) if 
      result.reply_tsps_ip1
    str += sprintf("%s=%d", result.reply_tsps_ip2, result.reply_tsps_ts2) if 
      result.reply_tsps_ip2
    str += sprintf("%s=%d", result.reply_tsps_ip3, result.reply_tsps_ts3) if 
      result.reply_tsps_ip3
    str += sprintf("%s=%d", result.reply_tsps_ip4, result.reply_tsps_ts4) if 
      result.reply_tsps_ip4
    return str
  end

  def rtt(result)
    return "-" if !result.responded?
    tx = Time.at(result.tx_sec, result.tx_usec)
    rx = Time.at(result.rx_sec, result.rx_usec)
    (rx-tx) * 1000
  end
  
end

class TraceTask

  attr_reader :taskid, :is_complete

  def initialize(taskid, target)
    @taskid = taskid
    @target = target

    log("#{@target}: trace starting at #{Time.now}");

    @trace_result = TraceResult.new(@target)
    @is_complete = false

    @ttl        = $options.firsthop

    @attempt    = 0
    @n          = 2 # used for confidence, assume two initially
    @loopc      = 0
    @iloopc     = 0

    @replies = []
    @probe_queue = []
    @pending_probes = 0
    
    @interfaces = []

    @state = :trace

    # i think that for the moment we can do all of the probing from this
    # one task.
    # reintroduce later if we need sub-tasks
    # @current_state = TspsDealiasSuitabilityTask.new(target, 
    #                                               @dealias_result)
  end
  
  def add_interface(interface)
    unless @interfaces.include?(interface)
      @interfaces << interface
      @n += 1
    end
  end
  
  def to_s
    "Task: #{@taskid} To: #{@target} TTL: #{@ttl}"
  end

  #def current_state
  #  return nil unless @current_state
  #  if @current_state.is_complete
  #    @current_state = @current_state.next_state
  #  end
  #  return @current_state
  #end

  # note to self, methods are called in this order:
  # is_complete ? nil : next_probe
  # so next_probe is only called if is_complete returns false
  # is_complete is ALWAYS called before next_probe

  def next_probe
    #current_state().next_probe
    # what is our next probe?
    if @probe_queue.length == 0 && @pending_probes == 0
      @attempt += 1
      @probe_queue << Probe.new(@target, @ttl, @attempt)
    end
    probe = @probe_queue.shift
    @pending_probes += 1 if probe
    return probe
  end

  def receive_probe(probe)
    #current_state().receive_probe(probe)
    # receive the probe!
    unless probe
      return
    end

    @pending_probes -= 1
    if @state == :trace
      if !probe.result.responded?
        receive_timeout_probe(probe)
      elsif probe.result.icmp_reply?
        receive_icmp_probe(probe)
      elsif probe.result.tcp_reply?
        receive_tcp_probe(probe)
      else
        $stderr.puts "FATAL ERROR: unknown reply type"
      end
    elsif @state == :lastditch
      if !probe.result.responded?
        receive_lastditch_timeout_probe(probe)
      else
        receive_lastditch_probe(probe)
      end
    end
  end

  def receive_icmp_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    # to make the port from scamper easier, we assume that we're not
    # going to probe any more as the default position of this method
    @is_complete = true

    # if this reply is not for the current ttl (i.e. a late reply),
    # check if we can stop now
    if(result.probe_ttl != @ttl)
      reason = stop_reason(result)
      if(reason != :stop_none)
        @trace_result.stop_reason = reason
        return
      end
    end

    ##
    # the rest of the code in this function deals with the fact this is a
    # reply for the current working hop.
    #
    # check if we are to send all allotted probes to the target
    ##
    if($options.all_allocated)
      if($options.confidence)
        $stderr.puts "FATAL ERROR: confidence and all_allocated cannot be "\
          "used simulaneously"
      end
      
      ##
      # if we get an out of order reply, then we go back to waiting for
      # the one we just probed for
      ##
      if(probe.attempt != @attempt)
        @is_complete = false
        return
      end

      ##
      # this response is for the last probe sent.  if there are still
      # probes to send for this hop, then send the next one
      ##
      if(@attempt < $options.attempts)
        @is_complete = false
        return
      end

    elsif($options.confidence)
      ##
      # record details of the interface, if its details are not
      # currently held
      ##
      add_interface(result.reply_src)

      if(@n <= CONFIDENCE_MAX_N)
        ##
        # if we get an out of order reply, then we go back to waiting for
        # the one we just probed for
        ##
        if(probe.attempt != @attempt)
          @is_complete = false
          return
        end

        ##
        # this response is for the last probe sent.  if there are still
        # probes to send for this hop, then send the next one
        ##
        if(@attempt < k(@n))
          @is_complete = false
          return
        end
      end

      ##
      # if we get to here, the confidence for this hop is done,
      # reset the state we keep about that stuff
      ##
      @n = 2
      @interfaces = []
    end

    ##
    # if we're in a mode where we only care about the first response to
    # a probe, then check it now.  the else block below handles the case
    # where we want a larger number of responses from a hop.
    ##
    if(!$options.confidence && !$options.all_allocated)
      #check to see if we have a stop reason from the ICMP response
      reason = stop_reason(result)
      if(reason != :stop_none)
        @trace_result.stop_reason = reason
        return
      end
    else
      # check all hop records for a reason to halt the trace
      # @trace_result.hops.each do |hop|
        #next unless hop
      checked = []
      hop.results.each do |tr|
        # there is no point checking if we have already checked this interface
        next if checked.include? tr.reply_src
        checked << tr.reply_src
        reason = stop_reason(tr)
        if(reason != :stop_none)
          @trace_result.stop_reason = reason
          return
        end
      end
      # end
    end
    
    # check if we've reached the hoplimit
    if(@trace_result.hops.length == 255 || 
       @trace_result.hops.length == $options.hoplimit)
      @trace_result.stop_reason = :stop_hoplimit
      return
    end

    #move on to the next ttl

    @attempt = 0
    @ttl += 1
    @trace_result.allocate_hop(@ttl)
    
    @is_complete = false
    return
    
  end

  def receive_tcp_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    # to make the port from scamper easier, we assume that we're not
    # going to probe any more as the default position of this method
    @is_complete = true

    # if we are sending all allotted probes to the target
    if($options.all_attempts)
      if(probe.attempts != @attempt)
        @is_complete = false
        return
      end
    elsif($options.confidence)
      # record details of the interface
      add_interface(result.reply_src)

      if(@n <= CONFIDENCE_MAX_N && @attempt < k(@n))
        @is_completed = false
        return
      end
    end

    @trace_reason = :stop_completed
    return
  end

  def receive_lastditch_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    # we received a reply from the destination, be done.

    @is_complete = true
    @trace_result.stop_reason = :gaplimit
    return
  end

  def receive_timeout_probe(probe)
    result = probe.result

    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    if(@attempt == $options.attempts)
      @is_complete = true
      hop.responsive = false
      # all probes for this hop have now been sent

      # scamper does a check to see if any of the other responses can be
      # used for a stop reason. this shouldnt apply for us, but let's do
      # it anyway.
      @trace_result.hops.each do |hop|
        next unless hop
        checked = []
        hop.results.each do |tr|
          next if checked.include? tr.reply_src
          checked << tr.reply_src
          reason = stop_reason(tr)
          if(reason != :stop_none)
            @trace_result.stop_reason = reason
            return
          end
        end
      end
      
      # check if we've reached the hoplimit
      if(@trace_result.hops.length == 255 || 
         @trace_result.hops.length == $options.hoplimit)
        @trace_result.stop_reason = :stop_hoplimit
        return
      end

      # see if a non-response for this hop brings us to the gap limit
      if(@trace_result.hops.length >= $options.gaplimit)
        # start at the current ttl -1 and go back gaplimit -1 hops
        # check if all of these hops are unresponsive
        deadpath = true
        (@ttl-1).downto(@ttl-($options.gaplimit-1)) do |i|
          hop = @trace_result.hop_at_ttl(i)
          if hop && hop.responsive
            deadpath = false
            break
          end
        end

        # add lastditch mode stuff in here
        if deadpath
          if $options.gapaction == :stop
            @trace_result.stop_reason = :gaplimit
          elsif $options.gapaction == :lastditch
            @is_complete = false
            @state = :lastditch
            @attempt = 0
            @ttl = 255
            @trace_result.allocate_hop(@ttl)
          else
            $stderr.puts "FATAL ERROR: invalid gapaction: $options.gapaction"
          end
          return
        end

      end
      @attempt = 0
      @ttl += 1
      @trace_result.allocate_hop(@ttl)
      @is_complete = false
    end
  end

  def receive_lastditch_timeout_probe(probe)
    result = probe.result

    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result
    
    if(@attempt == $options.attempts)
      # this is the last lastditch probe, give up!
      @is_complete = true
      @trace_result.stop_reason = :gaplimit
      return
    end
  end

  def is_complete
    if @is_complete
      puts @trace_result 
      log("#{@target}: trace complete at #{Time.now}")
    end
    return @is_complete
  end

  ###
  # decide if this result is a good enough reason to stop
  def stop_reason(result)
    
    ##
    # the message received is an ICMP port unreachable -- something that
    # the destination should have sent.  make sure the port unreachable
    # message makes sense based on the traceroute type.
    ##
  
    if(is_icmp_unreach_port(result) && (is_method(:udp) || is_method(:tcp)))
      reason = :stop_completed
    elsif(is_icmp_unreach(result))
      reason = :stop_unreach
    elsif(is_icmp_echo_reply(result))
      ##
      # the message received is an ICMP echo reply -- something that only
      # makes sense to include as part of the traceroute if the traceroute
      # is using echo requests.
      ##
      if(is_method(:icmp))
        reason = :stop_completed
      else
        reason = :stop_none
      end
    elsif($options.loops != 0 && is_loop(result)) 
      # checked for and found loop condition
      reason = :stop_loop
    elsif(is_icmp_ttl_exp(result) && $options.not_time_exceeded == false &&
          is_target(result))
      ##
      # if an ICMP TTL expired message is received from an IP address
      # matching the destination being probed, and the traceroute is
      # to stop when this occurs, then stop.
      ##
      reason = :stop_completed
    elsif(is_method(:tcp) && result.tcp_reply?)
      reason = :stop_completed
    else
      reason = :stop_none
    end
    
    return reason
  end
  
  def is_method(method)
    return $options.probe_method == method
  end
  
  def is_icmp_ttl_exp(result)
    (!is_method(:tcp) || result.reply_icmp_type == 11)
  end
  
  def is_icmp_ttl_exp_trans(result)
    (!is_method(:tcp) && 
     result.reply_icmp_type == 11 && result.reply_icmp_code == 0)
  end
  
  def is_icmp_unreach(result)
    (!is_method(:tcp) && result.reply_icmp_type == 3)
  end

  def is_icmp_unreach_port(result)
    (!is_method(:tcp) &&
     result.reply_icmp_type == 3 && result.reply_icmp_code == 3)
  end
  
  def is_icmp_echo_reply(result)
    (!is_method(:tcp) && result.reply_icmp_type == 0)
  end
  
  def is_target(result)
    (@target == result.reply_src)
  end
  
  def is_loop(result)

    # need at least a couple of probes first
    if(result.probe_ttl <= $options.firsthop)
      return false
    end

    one_adjacent = false

    # compare all hop records until the hop prior to this one
    (result.probe_ttl-1).downto($options.firsthop) do |i|

      checked_interfaces = []

      # all the results for the hop
      @trace_result.hop_at_ttl(i).results.each do |res|

        next unless res.responded?

        # only check an address once per hop
        next if checked_interfaces.include? res.reply_src

        checked_interfaces << res.reply_src
        # if the addresses match, then there is a loop
        if(res.reply_src == result.reply_src)

          # if the loop is between adjacent hops
          if(res.probe_ttl + 1 == result.probe_ttl)
            
            ##
            # check for zero-ttl forwarding.  continue probing if
            # the condition is met.
            ##
            if(res.reply_qttl == 0 && result.reply_qttl == 1)
              return false
            end
            
            # mark these as adjacent so that if the next interface
            # is also repeated we can mark that as a loop, otherwise,
            # mark this as an adjacent loop
            one_adjacent = true

            # move on to the next hop 
            # (i.e. ignore any other results at this hop)
            break

          elsif(res.probe_ttl + 2 == result.probe_ttl && one_adjacent)

            # this loop has one interface in the middle: AXA
            # and we saw AA at the last hop, so we can infer AAA
            return true

          end # we're looking at identical addresses but not at adjacent hops

          # these interfaces are not adjacent
          one_adjacent = false
          
          # check if the loop condition is met
          #@loopc += 1
          #if(@loopc >= $options.loops)
          #  return true
          #end
          
          #this assumes that $options.loops == 1
          # if it is set to 0, this is checked earlier.
          # setting loops to > 1 is silly and is not allowed
          # by the arg parse.
          # if you want the check for the number of 'loops' back,
          # then comment the following line and uncommend the four
          # lines above plus the break below
          return true

          # break
        elsif(one_adjacent)
          # this address is not the same as the test address, but
          # we previously saw AA, so assume we are at AAX and increment
          # the count of adjacent interface loops

          if(@iloopc < $options.loopaction)
            @iloopc += 1
            one_adjacent = false
            break # look for other loops
          else 
            return true
          end
        end # addresses are not the same, nor is one_adjacent set

      end # result loop

    end # hop loop

    # got all the way back to the start of the path with no loop
    return false
    
  end
  
end #TraceTask

#################################################################################
# STATIC HELPER METHODS
#################################################################################

$k = [
      [   0,   0 ], [   0,   0 ], [   6,   8 ], [  11,  15 ], [  16,  21 ],
      [  21,  28 ], [  27,  36 ], [  33,  43 ], [  38,  51 ], [  44,  58 ],
      [  51,  66 ], [  57,  74 ], [  63,  82 ], [  70,  90 ], [  76,  98 ],
      [  83, 106 ], [  90, 115 ], [  96, 123 ], [ 103, 132 ], [ 110, 140 ],
      [ 117, 149 ], [ 124, 157 ], [ 131, 166 ], [ 138, 175 ], [ 145, 183 ],
      [ 152, 192 ], [ 159, 201 ], [ 167, 210 ], [ 174, 219 ], [ 181, 228 ],
      [ 189, 237 ], [ 196, 246 ], [ 203, 255 ], [ 211, 264 ], [ 218, 273 ],
      [ 226, 282 ], [ 233, 291 ], [ 241, 300 ], [ 248, 309 ], [ 256, 319 ],
      [ 264, 328 ], [ 271, 337 ], [ 279, 347 ], [ 287, 356 ], [ 294, 365 ],
      [ 302, 375 ], [ 310, 384 ], [ 318, 393 ], [ 326, 403 ], [ 333, 412 ],
      [ 341, 422 ], [ 349, 431 ], [ 357, 441 ], [ 365, 450 ], [ 373, 460 ],
      [ 381, 470 ], [ 389, 479 ], [ 397, 489 ], [ 405, 499 ], [ 413, 508 ],
      [ 421, 518 ], [ 429, 528 ], [ 437, 537 ], [ 445, 547 ], [ 453, 557 ],
      [ 462, 566 ], [ 470, 576 ], [ 478, 586 ], [ 486, 596 ], [ 494, 606 ],
      [ 502, 616 ], [ 511, 625 ], [ 519, 635 ], [ 527, 645 ], [ 535, 655 ],
      [ 544, 665 ], [ 552, 675 ], [ 560, 685 ], [ 569, 695 ], [ 577, 705 ],
      [ 585, 715 ], [ 594, 725 ], [ 602, 735 ], [ 610, 745 ], [ 619, 755 ],
      [ 627, 765 ], [ 635, 775 ], [ 644, 785 ], [ 652, 795 ], [ 661, 805 ],
      [ 669, 815 ], [ 678, 825 ], [ 686, 835 ], [ 695, 845 ], [ 703, 855 ],
      [ 712, 866 ], [ 720, 876 ], [ 729, 886 ], [ 737, 896 ], [ 746, 906 ],
    ]

CONFIDENCE_MAX_N = $k.length

def k(n)
  return $k[n][$options.confidence]
end

def log(message)
  $stderr.puts message if $options.full
end

#################################################################################

traceManager = TraceManager.new
traceManager.start
