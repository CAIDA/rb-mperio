#!/usr/bin/env ruby

#################################################################################
#
# Implements a traceroute algorithm using MperIO.
# 
# Algorithm ported from scamper (http://www.wand.net.nz/scamper)
#
#############################################################################

if $0 =~ /dev$/
  $: << "#{ENV['HOME']}/caida/rb-mperio/ext"
  $: << "#{ENV['HOME']}/caida/rb-mperio/lib"
#else
#  require 'rubygems'
end

require 'rubygems'

require 'ostruct'
require 'optparse'

require 'mperio'
require 'wartslib'

#never buffer stdout
$stdout.sync = true

$options = OpenStruct.new
$options.log_path = nil  # disable logging by default

$options.confidence = nil
$options.dport = nil
$options.firsthop = 1
$options.gaplimit = 5
$options.gapaction = :stop
$options.hoplimit = 255
$options.loops = 1
$options.loopaction = 0
$options.probe_method = :icmp
$options.attempts = 2
$options.all_allocated = false
$options.not_time_exceeded = false
$options.spacing = 0
$options.concurrency = nil
$options.recordroute = 0
$options.test = false

opts = OptionParser.new

opts.banner="usage: #{$0} [-?fv] [-n concurrency] [-s spacing] [-l logfile]\n"\
 + " " * $0.to_s.length + "        -p mperport -c candidatefile | IPa IPb"

opts.on("-a", "--attempts=NUM", Integer,
         "specifies the maximum number of attempts to obtain a response " \
         "per hop (default: 2)") do |v|
  $options.attempts = v
end

opts.on("-b", "--log=PATH", "mper command/result message log path") do |v|
  $options.log_path = v
end

opts.on("-c", "--confidence=NUM", Integer,
        "specifies that a hop should be probed to a specified confidence "\
        "level (95% or 99%) to be sure the trace has seen all interfaces "\
        "that will reply for that hop.") do |v|
  case v
  when 95:
    $options.confidene = 0
  when 99:
    $options.confidence = 1
  else
    raise OptionParser::ParseError
  end
end

opts.on("-d", "--dport=NUM", Integer,
        "specifies the base destination port value to use for UDP-based " \
        "and TCP-based traceroute methods. For ICMP-based methods, this " \
        "option has no effect.") do |v|
  $options.dport = v
end

opts.on("-D", "--mper-port=NUM", Integer,
	"mper control socket port (REQUIRED)") do |v|
  $options.mper_port = v
end

opts.on("-f", "--firsthop=NUM", Integer, 
        "specifies the TTL or HLIM value to begin probing with (default: 1)"
        ) do |v|
  $options.firsthop = v
end

opts.on("-g", "--gaplimit=NUM", Integer, 
        "specifies the number of unresponsive hops permitted until a check " \
        "is made to see if the destination will respond. Zero is unlimited " \
        "(default: 5)") do |v|
  $options.gaplimit = v
end

opts.on("-G", "--gapaction=STR", String,
        "specifies what should happen if the gaplimit condition is met. " \
        "stop: halt probing, lastditch: send last-ditch probes.") do |v|
  if v == "stop"
    $options.gapaction = :stop
  elsif v == "lastditch"
    $options.gapaction = :lastditch
  else
    raise OptionParser::ParseError
  end
end

opts.on("-i", "--targets=PATH",
        "file with target address information") do |v|
  $options.target_path = v
end

opts.on("-I", "--wartsfile=PATH",
        "warts format output from scamper to be used as the topology data " \
        "for simulating traces (i.e. do not connect to mper)") do |v|
  $options.wartsfile = v
end

opts.on("-l", "--loops=NUM", Integer,
        "a value of 1 enables loop checking (default), whereas a value of " \
        "0 disables loop checking.") do |v|
  if v == 1 || v == 0
    $options.loops = v
  else
    raise OptionParser::ParseError
  end
end

opts.on("-L", "--loopaction=NUM", Integer,
        "specifies the number of 'adjacent interface' loops to allow. " \
        "a value of 0 means that the first set of identical adjacent " \
        "interfaces will cause the trace to halt, 1 the second set (i.e. "\
        "allow 1 set)"
        ) do |v|
  $options.loopaction = v
end

opts.on("-m", "--maxttl=NUM", Integer, 
        "specifies the maximum TTL or HLIM value that will be probed.  By "\
        "default, there is no restriction, apart from the 255 hops that "\
        "the Internet protocols allow.") do |v|
  $options.hoplimit = v
end

opts.on("-n", "--concurrency=NUM", Integer,
        "max addresses to trace concurrently (default: unlimited - be careful,"\
        " this will try and trace all interfaces simultaneously)") do |v|
  $options.concurrency = v
end

opts.on("-P", "--method=STR", String,
        "icmp: probe with ICMP echo request (paris depends on mper) (default), "\
        "udp: probe with UDP packets, or tcp: TCP ACK") do |v|
  $stderr.puts "v: #{v}"
  case v
  when "icmp":
      $options.probe_method = :icmp
  when "udp":
      $options.probe_method = :udp
  when "tcp":
      $options.probe_method = :tcp
  else
    raise OptionParser::ParseError
  end
end

opts.on("-Q", "--all-allocated", TrueClass,
        "specifies that all allocated probes are sent, regardless of how "\
        "many responses have been received.") do |v|
  $options.all_allocated = v
end

opts.on("-R", "--recordroute", TrueClass,
        "enable the record route IP option (default: off)") do |v|
  $options.rr = 1
end

opts.on("-s", "--test", TrueClass,
        "use the test harness rather than MperIO") do |v|
  $options.test = true
end

opts.on("-S", "--src-addr=ADDR", String,
        "specifies the source address to use in probes.  The address "\
        "cannot be spoofed.") do |v|
  $options.src_addr = v
end

opts.on("-t", "--tsps=STR", String,
        "addresses to use for the prespecified timestamp IP option. "\
        "format: ip1[,ip2[,ip3[,ip4]]]") do |v|
  $options.tsps = v.split(",")
end

opts.on("-T", "--not-time-exceeded", TrueClass,
        "specifies that time exceeded messages from the destination do not "\
        "cause the trace to be defined as reaching the destination.") do |v|
  $options.not_time_exceeded = v
end

opts.on("-v", "--[no-]verbose", TrueClass,  "show detailed progress") do |v|
  $options.verbose = v
end

opts.on("-V", "--full", TrueClass, "show full result output") do |v|
  $options.full = v
end

opts.on("-w", "--timeout=NUM", Integer,
        "specifies how long to wait, in seconds, for a reply.  By default, "\
        "a value of 5 is used.") do |v|
  $options.timeout = v
end

opts.on("-W", "--wait-probe=NUM", Integer,
        "specifies the minimum time to wait, in 10s of milliseconds, "\
        "between sending consecutive probes.  By default the next probe is "\
        "sent as soon as possible.") do |v|
  $options.spacing = v
end

opts.on("-z", "--tos=HEX", String,
        "specifies the value to set in the IP ToS/DSCP + ECN byte.  By "\
        "default, this byte is set to zero.") do |v|
  $options.tos = v.hex
end

opts.on_tail("-?", "--help", "show this message") do
  puts opts
  exit
end

begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!.to_s + "\n\n"
  $stderr.puts opts
  exit 1
end

unless $options.mper_port || $options.test || $options.wartsfile
  $stderr.puts "ERROR: missing mper port\n\n"
  $stderr.puts opts
  exit -1
end

unless $options.target_path || ARGV.length >= 1 || $options.test ||
    $options.wartsfile
  $stderr.puts "ERROR: target file path "\
    "or at least one address must be specified\n\n"
  $stderr.puts opts
  exit -1
end

if $options.confidence && $options.all_allocated
  $stderr.puts "ERROR: only one of 'confidence' or 'all-allocated' may " \
  "be specified at once"
  $stderr.puts opts
  exit -1
end

if $options.hoplimit && $options.hoplimit < $options.firsthop
  $stderr.puts "ERROR: firsthop is set further than the hoplimit"
  $stderr.puts opts
  exit -1
end

if $options.tsps && $options.rr
  $stderr.puts "ERROR: only one of tsps and record route may be specified " \
  "at once"
  $stderr.puts opts
  exit -1
end

#============================================================================

class TargetFile

  attr_reader :current_target

  def initialize(target_path)
    @target_path = target_path
    @target_io = File.open target_path
    @done = false
    advance
  end

  def advance
    if @done
      @current_target = nil
    else
      loop do
        line = @target_io.gets
        if line
          next if line =~ /^\#/ || line =~ /^\s*$/
          line.chomp!
          @current_target = line
          break
        else
          @done = true
          @current_target = nil
          break
        end
      end
    end
    return @current_target
  end

end

class ImmediateTargets

  def initialize(targets)
    @targets = targets
    advance
  end
  
  def validate_ip(ip)
    if ip =~ /^\d+\.\d+\.\d+\.\d+$/
      ip
    else
      $stderr.puts "ERROR: malformed target ip: \"#{ip}\""
      advance
    end
  end
  
  def current_target
    @current_target
  end
  
  def advance
    @current_target = @targets.shift
  end
end

#============================================================================
class TraceManager
  
  def initialize

    # the list of tasks (must implement next_probe, receive_probe and taskid)
    @pending_tasks = []
    @next_task_id = 1

    @pending_probes = {}
    @next_probe_id = 1
    
    # initialize the list of addresses to probe
    if $options.target_path
      @targets = TargetFile.new $options.target_path
    else
      @targets = ImmediateTargets.new ARGV
    end
    
    # initialize the mper connection
    begin
      @mperio = MperIO.new $options.mper_port, $options.log_path
      @mperio.delegate = self
    rescue
      $stderr.puts "Failed to connect to mper on port " +
        "#{$options.mper_port}. Is mper running? Is the log path valid?"
      exit -1
    end
    
  end
  
  def start
    @mperio.start
  end
  
  def stop
    @mperio.stop
  end
  
  def get_next_task_id
    id = @next_task_id
    @next_task_id += 1
    return id
  end
  
  def get_next_probe_id
    id = @next_probe_id
    @next_probe_id += 1
    return id
  end
  
  ####
  # used by the TraceTask objects to queue a probe that they want sent
  #
  def queue_probe(task, probe)
    probe.id = get_next_probe_id()
    probe.task = task
    # if $options.verbose
    #  printf "probing (%s|%s) @ %d\n", probe.dest, tsps_ips_s, probe.id 
    # end
    @pending_probes[probe.id] = probe

    case $options.probe_method
      when :icmp
      @mperio.ping_icmp(probe.id, probe.dest, :ttl, probe.ttl,
                        :src_addr, $options.src_addr,
                        :tos, $options.tos,
                        :timeout, $options.timeout,
                        :spacing, $options.spacing,
                        :tsps, $options.tsps,
                        :rr, $options.rr)
      when :udp
      @mperio.ping_udp(probe.id, probe.dest, :ttl, probe.ttl,
                       :dport, $options.dport,
                       :src_addr, $options.src_addr,
                       :tos, $options.tos,
                       :timeout, $options.timeout,
                       :spacing, $options.spacing)

    when :tcp
      @mperio.ping_tcp(probe.id, probe.dest, :ttl, probe.ttl,
                       :dport, $options.dport,
                       :src_addr, $options.src_addr,
                       :tos, $options.tos,
                       :timeout, $options.timeout,
                       :spacing, $options.spacing)
      
      else fail "INTERNAL ERROR: invalid probing method"
    end
  end
  
  ####
  # used by this object to find the probe object for the given reply
  def match_result(result)
    probe = @pending_probes.delete result.reqnum
    return probe
  end
  
  def fill_task_queue
    while (target = @targets.current_target) != nil
      if $options.concurrency && @pending_tasks.length >= $options.concurrency
        @reached_concurrency = true
        break
      end
      task = TraceTask.new(get_next_task_id(), target, $options)
      @pending_tasks.push task
      @targets.advance
    end
  end
  
  def mperio_on_more
    # fill the task list
    fill_task_queue()
    
    # send the next probe - whatever it may be
    probe_next_task()

    if @pending_tasks.length == 0 && @pending_probes.length == 0
      stop()
    end
  end

  def probe_next_task
    task_cnt = @pending_tasks.length

    # we allow ourselves at most one pass through the list
    # if no tasks can muster up a probe to send after one
    # pass, then we're either done, or they are all waiting
    # for responses, we might as well wait too.
    task_cnt.times do |i|
      # remove the next task from the head of the list
      task = @pending_tasks.shift

      # the list is empty - all tasks are complete
      unless task
        break
      end
      
      # no need to continue probing it
      if task.is_complete
        # we only support ASCII output at the moment, so dump the result
        puts task.result
        # add another task (if there are any remaining)
        fill_task_queue()
        # we haven't managed to send a probe yet, keep trying
        probe_next_task()
        # we either sent a probe, or we completed a full cycle,
        # either way, we're not going to look for any more probes
        break
      else
        # the task is still active
        # append it to the 'tail' of the list
        @pending_tasks.push task
        
        # ask for the next probe it wants to send
        probe =  task.next_probe
        if probe
          # it still has a probe that it would like to send
          queue_probe(task, probe)
          # at this point, we have definitely sent a probe
          # no more more
          @more = false
          # the probe is sent, lets not send any more until mper asks us to
          break
        else
          # we didn't manage to send a probe, so let's keep that in mind
          @more = true
        end
      end
    end
  end
  
  def mperio_on_data(result)
    #printf "mperio_on_data: %p\n", result #if $options.verbose

    probe = match_result(result)

    if probe
      probe.result = result
      probe.task.receive_probe(probe)
    else
      $stderr.puts "ignoring duplicate reply received from " +
        "#{result.probe_dest} for probe #{result.reqnum}"
      # exit -1
    end

    fill_task_queue()

    if @more
      mperio_on_more()
    end
  end


  def mperio_on_error(reqnum, message)
    $stderr.printf "mperio_on_error: reqnum=%d msg=%s\n", reqnum, message
    @mperio.stop
    exit 1
  end


  def mperio_on_send_error(reqnum, message)
    $stderr.printf "mperio_on_send_error: reqnum=%d msg=%s\n", reqnum, message
    @pending_tasks.remove reqnum
    @mperio.suspend if @pending_tasks.length == 0 && @queued_tasks.length == 0
  end


  def mperio_service_failure(message)
    $stderr.printf "mperio_service_failure: %s\n", message
    @mperio.stop
    exit 1
  end

end

################################################################################
################################################################################
# Simulator classes
#
# The following classes are a logical grouping of the classes which are used
# to perform traceroutes using existing warts data. That is, data which has
# already been captured by a scamper process. This can be used to test the 
# behavior of the TraceTask classes in specific situations.
#
################################################################################
################################################################################


#==============================================================================
# TraceSim
#
# TraceSim is the top-level manager class for the warts simulator. It is
# responsible for extracting the trace data from the warts file and executing
# the individual traces.
#
#==============================================================================
class TraceSim

  def initialize
    @warts = Warts::File::open $options.wartsfile
    @warts.add_filters Warts::TRACE
    @taskid = 1
    @reqnum = 1
  end

  def next_taskid
    @taskid += 1
    return @taskid-1
  end

  def next_reqnum
    @reqnum += 1
    return @reqnum-1
  end

  def scamper_stop_to_symbol(stop_reason)
    case stop_reason
    when 0:
        return :stop_none
    when 1:
        return :stop_completed
    when 2:
        return :stop_unreach
    when 3:
        return :stop_icmp
    when 4:
        return :stop_loop
    when 5:
        return :stop_gaplimit
    when 6:
        return :stop_error
    when 7:
        return :stop_hoplimit
    when 8:
        return :stop_gss
    when 9:
        return :stop_halted
    else raise "unknown stop condition"
    end
  end
    
  def scamper_trace_to_ascii(trace)
    str = "traceroute to #{trace.dst}\n"
    expected_response = 0
    last_hop = nil
    attempts = trace.attempts
    trace.each do |hop, response, hop_exists|
      if last_hop != hop
        last_hop = hop
        expected_response = 0
      end

      if response == 0
        str += (hop+1).to_s
      end
      #if response > expected_response
        # print out some *'s to get us to the right place
      #  str += sprintf("\t*\n") * (response-expected_response)
      #end
      if hop_exists
        str += sprintf("\t%s\t\%s ms\n", trace.hop_addr(hop, response),
                       trace.hop_rtt_str(hop, response))
      else
        str += sprintf("\t*\n")# * attempts
      end
    end
   
    # a somewhat naive way to convert scamper's old stop_completed to
    # stop_unreach based on the icmp type of the last response
    if scamper_stop_to_symbol(trace.stop_reason) == :stop_completed && 
        trace.hop_icmp_type(trace.hop_count-1) == 3 &&
        trace.hop_icmp_code(trace.hop_count-1) == 3
      str += "stop reason: stop_unreach\n"
    else
      str += "stop reason: #{scamper_stop_to_symbol(trace.stop_reason)}\n"
    end

  end
      
  def insert_result(probe, trace)
    # we need the details for the hop at probe.ttl, result at probe.attempt
    hop = probe.ttl-1
    res = probe.attempt-1

    result = SimResult.new
    
    result.reqnum = next_reqnum
    result.probe_src = trace.src
    result.probe_dest = trace.dst
    result.probe_ttl = probe.ttl
    result.probe_ipid = probe.attempt

    if trace.hop_exists?(hop, res)
      result.responded = true
      result.tx_sec = 0
      result.tx_usec = 0
      result.rx_sec = trace.hop_rtt_sec(hop, res)
      result.rx_usec = trace.hop_rtt_usec(hop, res)
      result.reply_src = trace.hop_addr(hop, res)
      result.reply_ttl = trace.hop_reply_ttl(hop, res)
      result.reply_qttl = trace.hop_inner_ipttl(hop, res)
      result.reply_ipid = trace.hop_reply_ipid(hop, res)

      if trace.hop_has_icmp_reply?(hop, res)
        result.reply_icmp_type = trace.hop_icmp_type(hop, res)
        result.reply_icmp_code = trace.hop_icmp_code(hop, res)
      elsif trace.hop_has_tcp_reply?(hop, res)
        result.reply_tcp = trace.hop_tcp_flags(hop, res)
      end

    else
      result.responded = false
    end

    probe.result = result
    return probe
  end
  
  def insert_timeout(probe, trace)
    result = SimResult.new
    
    result.reqnum = next_reqnum
    result.probe_src = trace.src
    result.probe_dest = trace.dst
    result.probe_ttl = probe.ttl
    result.probe_ipid = probe.attempt
    result.responded = false

    probe.result = result
    return probe
  end

  def start
    pass_cnt = 0
    total_cnt = 0

    @warts.read do |trace|
      total_cnt += 1
      scamper_output = scamper_trace_to_ascii(trace)


      # check if this is a zero-ttl forwarding case
      if scamper_stop_to_symbol(trace.stop_reason) == :stop_loop
        if trace.hop_inner_ipttl(trace.hop_count-1) == 1 && 
          trace.hop_inner_ipttl(trace.hop_count-2) == 0
          # this is zttl
          zttl = true
        end
        if trace.hop_addr(trace.hop_count-1) == 
            trace.hop_addr(trace.hop_count-2)
          # check for zttl earlier in the path
          trace.hop_count.downto(2) do |i|
            if trace.hop_exists?(i) && trace.hop_inner_ipttl(i-2) == 1 &&
                trace.hop_inner_ipttl(i-2) == 0
              zttl = true
            end
          end
        end
      end

      if zttl
        puts "skipping #{trace.list_monitor} #{trace.dst} zero-ttl"
        next
      end
      
      $options.attempts = trace.attempts
      $options.hoplimit = trace.hoplimit
      $options.gaplimit = trace.gaplimit
      $options.firsthop = trace.firsthop
      $options.tos = trace.tos
      $options.loops = trace.loops
      $options.loopaction = 1

      task = TraceTask.new(next_taskid, trace.dst, $options)

      late_queue = []
      destination_queue = []

      while !task.is_complete && (probe = task.next_probe) != nil
        duplicate_queue = []
        
        if trace.hop_exists?(probe.ttl-1, probe.attempt-1) && 
            trace.hop_rtt(probe.ttl-1, probe.attempt-1) > 
            trace.wait * 1000
          # send a timeout and save this for later
          late = probe.clone
          insert_result(late, trace)

          if late.result.reply_src == trace.dst
            destination_queue << late
          else
            late_queue << late
          end
          insert_timeout(probe, trace)
        else
          insert_result(probe, trace)
          response = probe.attempt + 1
          while(trace.hop_exists?(probe.ttl-1, response-1))
            duplicate = probe.clone
            duplicate.attempt = response
            insert_result(duplicate, trace)
            #task.receive_probe(duplicate)
            duplicate_queue << duplicate
            response += 1
          end
        end
        
        while(late_queue.length > 0 && 
              (late_queue[0].ttl < probe.ttl || probe.ttl == trace.hop_count))
          task.receive_probe(late_queue.shift) 
        end
        
        duplicate_queue.each do |duplicate|
          task.receive_probe(duplicate)
        end

        task.receive_probe(probe)
        
        if probe.ttl == trace.hop_count
          # return the destination probes
          destination_queue.each do |p|
            task.receive_probe(p)
          end
        end
      end

      if task.is_complete
        if scamper_output == task.result.scamper_to_s
          #puts "simulated trace to #{trace.dest} passed" if $options.verbose
          pass_cnt += 1
        elsif $options.verbose
          puts "simulated trace to #{trace.dest} failed"
          puts "scamper:"
          puts scamper_output
          puts "mper-trace:"
          puts task.result.scamper_to_s
          puts "\n\n"
        end
      else
        raise "Task did not complete"
      end

    end
    pct = pass_cnt / total_cnt.to_f * 100
    printf("%d of %d traces passed the simulation (%.2f%%)\n", 
           pass_cnt, total_cnt, pct)

  end

end #TraceSim

class SimResult
  
  attr_accessor :reqnum
  attr_accessor :probe_src, :probe_dest, :udata
  attr_accessor :tx_sec, :tx_usec, :rx_sec, :rx_usec
  attr_accessor :probe_ttl, :probe_ipid, :reply_src, :reply_ttl, :reply_qttl
  attr_accessor :reply_rr
  attr_accessor :reply_tsps_ts1, :reply_tsps_ip1
  attr_accessor :reply_tsps_ts2, :reply_tsps_ip2
  attr_accessor :reply_tsps_ts3, :reply_tsps_ip3
  attr_accessor :reply_tsps_ts4, :reply_tsps_ip4
  attr_accessor :reply_ipid

  attr_accessor :responded
  attr_accessor :reply_icmp_type, :reply_icmp_code
  attr_accessor :reply_tcp
  
  def responded?
    @responded
  end
  
  def icmp_reply?
    @reply_icmp_type != nil
  end
  
  def tcp_reply?
    @reply_tcp != nil
  end
  
  def reply_tcp_flags
    @reply_tcp
  end
  
  # Just a convenience function.  This returns the same strings as warts-dump.
  def decompose_tcp_flags
    return nil unless @reply_tcp
    retval = []
    retval << "fin" if (@reply_tcp & 0x01) != 0
    retval << "syn" if (@reply_tcp & 0x02) != 0
    retval << "rst" if (@reply_tcp & 0x04) != 0
    retval << "psh" if (@reply_tcp & 0x08) != 0
    retval << "ack" if (@reply_tcp & 0x10) != 0
    retval << "urg" if (@reply_tcp & 0x20) != 0
    retval << "ece" if (@reply_tcp & 0x40) != 0
    retval << "cwr" if (@reply_tcp & 0x80) != 0
    retval
  end
  
end

################################################################################
################################################################################
# Test Harness classes
#
# The following classes are a logical grouping of the classes which are used
# to simulate specific path conditions designed to test the traceroute
# implementation.
#
################################################################################
################################################################################


#==============================================================================
# TraceTest
#
# The TraceTest class manages the collection of Test Set instances that will
# be used for testing. The structure is hierarchical, so each test set has
# a collection of actual tests, each of which may contain a set of sub-tests.
#
#==============================================================================
class TraceTest

  def initialize
    @sets = []
    @sets << TraceTestResponseTestSet.new
    @sets << TraceTestTopologyTestSet.new
    @sets << TraceTestLoopTestSet.new
    # others

  end #initialize

  def start
    @sets.each do |set|
      puts "Excecuting #{set}..."
      set.execute_all
    end
  end #start

  def self.generate_ip(ttl, attempt)
    return "%d.%d.%d.%d" % [192,168,ttl,attempt]
  end

end # TraceTest

class TraceTestResponseTestSet

  def initialize
    @tests = []
    @tests << TraceTestResponseUnreachTest.new
    @tests << TraceTestResponseTcpFlagTest.new
    @tests << TraceTestResponseTtlExpiredTest.new
  end

  def execute_all
    @tests.each do |test|
      test.execute_all
    end
  end

  def to_s
    "TraceTest Response Test Set"
  end

end #TraceTestResponseTestSet

class TraceTestResponseUnreachTest

  def initialize
    @test_number = 1
  end

  def to_s
    "TraceTest Response Unreachable Test"
  end

  def execute_all
    execute_method_tests(:icmp)
    execute_method_tests(:udp)
    execute_method_tests(:tcp)
  end

  def execute_method_tests(method)
    execute_test(method, :port)
    execute_test(method, :proto)
    execute_test(method, :host)
    execute_test(method, :admin)
    execute_test(method, :admin_dest)
    execute_test(method, :net)
  end

  def execute_test(method, type)
    test_name = "#{self.to_s} (#{method}, #{type})"
    puts "Executing #{test_name}" if $options.verbose

    # 'work out' some of the features of our path
    path_length = 8 #rand(20) + 5
    source = TraceTest.generate_ip(0,0)
    target = TraceTest.generate_ip(path_length,1)
    time = Time.now
    taskid = @test_number
    @test_number += 1
    reqnum = 1

    puts "Path Length: #{path_length}" if $options.verbose
    puts "Source: #{source}" if $options.verbose
    puts "Destination: #{target}" if $options.verbose

    $options.probe_method = method

    task = TraceTask.new(taskid, target, $options)

    while !task.is_complete && (probe = task.next_probe) != nil
      # create a response and pass it back to the task
      probe.id = reqnum
      #puts probe

      probe.result = result = TestResult.new(reqnum, source, probe.dest, 
                                            probe.ttl, time, probe.attempt)
      reqnum += 1
      time += 10
      
      result.responded = true
      result.reply_icmp = true

      if probe.ttl == path_length
        # send the weird response
        result.reply_icmp_type = 3
        result.reply_src = target
        case type
        when :port:
            result.reply_icmp_code = 3
        when :proto:
            result.reply_icmp_code = 2
        when :host:
            result.reply_icmp_code = 1
        when :admin:
            result.reply_icmp_code = 13
        when :admin_dest:
            result.reply_icmp_code = 10
        when :net:
            result.reply_icmp_code = 0
        else raise "missing test case"
        end
      else
        # send a normal response
        # type: 11, code: 0
        result.reply_icmp_type = 11
        result.reply_icmp_code = 0
      end
      
      task.receive_probe(probe)

    end

    puts task.result if $options.verbose

    if task.result.to_s == expected_result(method, type)
      puts "#{test_name} passed"
    else
      puts "#{test_name} failed"
      puts task.result
    end

  end

  def expected_result(method, type)
    if (method == :udp || method == :tcp) && type == :port
"traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
stop reason: stop_completed
"
    else
      "traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
stop reason: stop_unreach
"
    end
  end
  
end #TraceTestResponseUnreachTest

class TraceTestResponseTcpFlagTest

  def initialize
    @test_number = 1
  end

  def to_s
    "TraceTest Response Tcp Flag Test"
  end

  def execute_all
    execute_test(:fin)
    execute_test(:syn)
    execute_test(:rst)
    execute_test(:psh)
    execute_test(:ack)
    execute_test(:urg)
    execute_test(:ece)
    execute_test(:cwr)
    execute_test(:syn_ack)
  end

  def execute_test(type)
    test_name = "#{self.to_s} (#{type})"
    puts "Executing #{test_name}" if $options.verbose

    # 'work out' some of the features of our path
    path_length = 8#rand(20) + 5
    source = TraceTest.generate_ip(0,0)
    target = TraceTest.generate_ip(path_length,1)
    time = Time.now
    taskid = @test_number
    @test_number += 1
    reqnum = 1

    puts "Path Length: #{path_length}" if $options.verbose
    puts "Source: #{source}" if $options.verbose
    puts "Destination: #{target}" if $options.verbose

    $options.probe_method = :tcp

    task = TraceTask.new(taskid, target, $options)

    while !task.is_complete && (probe = task.next_probe) != nil
      # create a response and pass it back to the task
      probe.id = reqnum
      #puts probe

      probe.result = result = TestResult.new(reqnum, source, probe.dest, 
                                            probe.ttl, time, probe.attempt)
      reqnum += 1
      time += 10
      
      result.responded = true

      if probe.ttl == path_length
        # send the weird response
        result.reply_src = target
        case type
        when :fin:
            result.reply_tcp = 0x01
        when :syn:
            result.reply_tcp = 0x02
        when :rst:
            result.reply_tcp = 0x04
        when :psh:
            result.reply_tcp = 0x08
        when :ack:
            result.reply_tcp = 0x10
        when :urg:
            result.reply_tcp = 0x20
        when :ece:
            result.reply_tcp = 0x40
        when :cwr:
            result.reply_tcp = 0x80
        when :syn_ack:
            result.reply_tcp = 0x02
          result.reply_tcp &= 0x10
        else raise "unknown type #{type}"
        end
      else
        # send a normal response
        # type: 11, code: 0
        result.reply_icmp = true
        result.reply_icmp_type = 11
        result.reply_icmp_code = 0
      end
      
      task.receive_probe(probe)

    end

    puts task.result if $options.verbose

    if task.result.to_s == expected_result(type)
      puts "#{test_name} passed"
    else
      puts "#{test_name} failed"
      puts task.result
    end

  end

  def expected_result(type)
"traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
stop reason: stop_completed
"
  end
  
end #TraceTestResponseTcpFlagTest

class TraceTestResponseTtlExpiredTest

  def initialize
    @test_number = 1
  end

  def to_s
    "TraceTest Response TTL Expired Test"
  end

  def execute_all
    execute_method_tests(:icmp)
    execute_method_tests(:udp)
    execute_method_tests(:tcp)
  end

  def execute_method_tests(method)
    execute_test(method, :dest_exp_stop)
    execute_test(method, :dest_exp_ignore)
  end

  def execute_test(method, type)
    test_name = "#{self.to_s} (#{method}, #{type})"
    puts "Executing #{test_name}" if $options.verbose

    # 'work out' some of the features of our path
    path_length = 8 #rand(20) + 5
    dest_response_ttl = path_length + 3
    source = TraceTest.generate_ip(0,0)
    target = TraceTest.generate_ip(path_length,1)
    time = Time.now
    taskid = @test_number
    @test_number += 1
    reqnum = 1

    puts "Path Length: #{path_length}" if $options.verbose
    puts "Source: #{source}" if $options.verbose
    puts "Destination: #{target}" if $options.verbose

    $options.probe_method = method

    case type
    when :dest_exp_stop:
        $options.not_time_exceeded = false
    when :dest_exp_ignore:
        $options.not_time_exceeded = true
    end

    task = TraceTask.new(taskid, target, $options)

    while !task.is_complete && (probe = task.next_probe) != nil
      # create a response and pass it back to the task
      probe.id = reqnum
      #puts probe

      probe.result = result = TestResult.new(reqnum, source, probe.dest, 
                                            probe.ttl, time, probe.attempt)
      reqnum += 1
      time += 10
      
      result.responded = true
      result.reply_icmp = true
      result.reply_icmp_type = 11
      result.reply_icmp_code = 0

      if probe.ttl == path_length
        # match the address
        result.reply_src = target
      elsif probe.ttl == dest_response_ttl
        result.reply_src = target
        if method == :icmp
          result.reply_icmp_type = 0
          result.reply_icmp_code = 0
        elsif method == :udp
          result.reply_icmp_type = 3
          result.reply_icmp_code = 3
        else
          result.reply_icmp = nil
          result.reply_tcp = 0x04
        end
          
      end

      task.receive_probe(probe)

    end

    puts task.result if $options.verbose

    if task.result.to_s == expected_result(method, type)
      puts "#{test_name} passed"
    else
      puts "#{test_name} failed"
      puts task.result
    end

  end

  def expected_result(method, type)
    if type == :dest_exp_stop
      "traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
stop reason: stop_completed
"
    else
      "traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.8.1	1000.000 ms
stop reason: stop_completed
"
    end
  end
  
end #TraceTestResponseTtlExpiredTest

class TraceTestTopologyTestSet

  def initialize
    @tests = []
    @tests << TraceTestTopologyEarlyDestTest.new
    @tests << TraceTestTopologyPathLengthTest.new
    @tests << TraceTestTopologyMultipleResponsesTest.new
  end

  def execute_all
    @tests.each do |test|
      test.execute_all
    end
  end

  def to_s
    "TraceTest Topology Test Set"
  end

end #TraceTestTopologyTestSet

class TraceTestTopologyEarlyDestTest

  def initialize
    @test_number = 1
  end

  def to_s
    "TraceTest Topology Early Destination Test"
  end

  def execute_all
    execute_test(:icmp)
    execute_test(:udp)
    execute_test(:tcp)
  end

  def execute_test(method)
    test_name = "#{self.to_s} (#{method})"
    puts "Executing #{test_name}" if $options.verbose

    # 'work out' some of the features of our path
    path_length = 11 #rand(20) + 5
    dest_response_ttl = path_length - 3
    source = TraceTest.generate_ip(0,0)
    target = TraceTest.generate_ip(dest_response_ttl,1)
    time = Time.now
    taskid = @test_number
    @test_number += 1
    reqnum = 1

    late_response = nil

    puts "Path Length: #{path_length}" if $options.verbose
    puts "Source: #{source}" if $options.verbose
    puts "Destination: #{target}" if $options.verbose

    $options.probe_method = method

    task = TraceTask.new(taskid, target, $options)

    while !task.is_complete && (probe = task.next_probe) != nil
      # create a response and pass it back to the task
      probe.id = reqnum
      #puts probe

      probe.result = result = TestResult.new(reqnum, source, probe.dest, 
                                            probe.ttl, time, probe.attempt)
      result.responded = true
      result.reply_icmp = true
      result.reply_icmp_type = 11
      result.reply_icmp_code = 0

      reqnum += 1
      time += 10

      # what we're trying to do here is simulate a reply from the destination
      # a couple of hops prior to the one we're currently probing at
      # the way we will do that is by forcing the ttl of the packet to be
      # at dest_response_ttl when the traceroute is expecting it to be
      # path_length
      
      if probe.ttl == dest_response_ttl
        # make a copy of this probe so that we can return it later
        if late_response # let the retry get a response
          # point out that this was the load balanced reply
          result.reply_src = TraceTest.generate_ip(dest_response_ttl, 99)
        else
          late_response = probe.clone
          late_response.result = TestResult.new(reqnum, source, probe.dest, 
                                     dest_response_ttl, time, probe.attempt)
          late_response.result.responded = true
          late_response.result.reply_icmp = true
          late_response.result.reply_src = target
          if method == :icmp
            # echo reply
            late_response.result.reply_icmp_type = 0
            late_response.result.reply_icmp_code = 0
          else
            # port unreach
            late_response.result.reply_icmp_type = 3
            late_response.result.reply_icmp_code = 3
          end

          result.responded = false
          result.reply_icmp = false
        end
      elsif probe.ttl == path_length
        # return the saved probe
        probe = late_response
      end
      task.receive_probe(probe)

    end

    puts task.result if $options.verbose

    if task.result.to_s == expected_result(method)
      puts "#{test_name} passed"
    else
      puts "#{test_name} failed"
      puts task.result
    end

  end

  def expected_result(method)
    return "traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	*
	192.168.8.99	1000.000 ms
	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
stop reason: stop_completed
"
  end
  
end #TraceTestTopologyEarlyDestTest

class TraceTestTopologyPathLengthTest

  def initialize
    @test_number = 1
  end

  def to_s
    "TraceTest Topology Path Length Test"
  end

  def execute_all
    execute_method_tests(:icmp)
    execute_method_tests(:udp)
    execute_method_tests(:tcp)
  end

  def execute_method_tests(method)
    execute_test(method, 1)
    execute_test(method, 2)
    execute_test(method, 44)
    execute_test(method, 254)
    execute_test(method, 1000)
  end

  def execute_test(method, path_length)
    test_name = "#{self.to_s} (#{method}, len:#{path_length})"
    puts "Executing #{test_name}" if $options.verbose

    # 'work out' some of the features of our path
    source = TraceTest.generate_ip(0,0)
    target = TraceTest.generate_ip(path_length,1)
    time = Time.now
    taskid = @test_number
    @test_number += 1
    reqnum = 1

    puts "Path Length: #{path_length}" if $options.verbose
    puts "Source: #{source}" if $options.verbose
    puts "Destination: #{target}" if $options.verbose

    $options.probe_method = method

    task = TraceTask.new(taskid, target, $options)

    while !task.is_complete && (probe = task.next_probe) != nil
      # create a response and pass it back to the task
      probe.id = reqnum
      #puts probe

      probe.result = result = TestResult.new(reqnum, source, probe.dest, 
                                            probe.ttl, time, probe.attempt)
      reqnum += 1
      time += 10
      
      result.responded = true
      result.reply_icmp = true

      if probe.ttl == path_length
        # match the address
        result.reply_src = target
        if method == :icmp
          result.reply_icmp_type = 0
          result.reply_icmp_code = 0
        else
          result.reply_icmp_type = 3
          result.reply_icmp_code = 3
        end
      else
        # ttl exp
        result.reply_icmp_type = 11
        result.reply_icmp_code = 0
      end

      task.receive_probe(probe)

    end

    puts task.result if $options.verbose

    if task.result.to_s == expected_result(method, path_length)
      puts "#{test_name} passed"
    else
      puts "#{test_name} failed"
      puts task.result
    end

  end

  def expected_result(method, path_length)
    case path_length
      when 1:
        return "traceroute to 192.168.1.1
1	192.168.1.1	1000.000 ms
stop reason: stop_completed
"
      when 2:
        return "traceroute to 192.168.2.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
stop reason: stop_completed
"
      when 44:
        return "traceroute to 192.168.44.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
13	192.168.13.1	1000.000 ms
14	192.168.14.1	1000.000 ms
15	192.168.15.1	1000.000 ms
16	192.168.16.1	1000.000 ms
17	192.168.17.1	1000.000 ms
18	192.168.18.1	1000.000 ms
19	192.168.19.1	1000.000 ms
20	192.168.20.1	1000.000 ms
21	192.168.21.1	1000.000 ms
22	192.168.22.1	1000.000 ms
23	192.168.23.1	1000.000 ms
24	192.168.24.1	1000.000 ms
25	192.168.25.1	1000.000 ms
26	192.168.26.1	1000.000 ms
27	192.168.27.1	1000.000 ms
28	192.168.28.1	1000.000 ms
29	192.168.29.1	1000.000 ms
30	192.168.30.1	1000.000 ms
31	192.168.31.1	1000.000 ms
32	192.168.32.1	1000.000 ms
33	192.168.33.1	1000.000 ms
34	192.168.34.1	1000.000 ms
35	192.168.35.1	1000.000 ms
36	192.168.36.1	1000.000 ms
37	192.168.37.1	1000.000 ms
38	192.168.38.1	1000.000 ms
39	192.168.39.1	1000.000 ms
40	192.168.40.1	1000.000 ms
41	192.168.41.1	1000.000 ms
42	192.168.42.1	1000.000 ms
43	192.168.43.1	1000.000 ms
44	192.168.44.1	1000.000 ms
stop reason: stop_completed
"
    when 254:
        return "traceroute to 192.168.254.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
13	192.168.13.1	1000.000 ms
14	192.168.14.1	1000.000 ms
15	192.168.15.1	1000.000 ms
16	192.168.16.1	1000.000 ms
17	192.168.17.1	1000.000 ms
18	192.168.18.1	1000.000 ms
19	192.168.19.1	1000.000 ms
20	192.168.20.1	1000.000 ms
21	192.168.21.1	1000.000 ms
22	192.168.22.1	1000.000 ms
23	192.168.23.1	1000.000 ms
24	192.168.24.1	1000.000 ms
25	192.168.25.1	1000.000 ms
26	192.168.26.1	1000.000 ms
27	192.168.27.1	1000.000 ms
28	192.168.28.1	1000.000 ms
29	192.168.29.1	1000.000 ms
30	192.168.30.1	1000.000 ms
31	192.168.31.1	1000.000 ms
32	192.168.32.1	1000.000 ms
33	192.168.33.1	1000.000 ms
34	192.168.34.1	1000.000 ms
35	192.168.35.1	1000.000 ms
36	192.168.36.1	1000.000 ms
37	192.168.37.1	1000.000 ms
38	192.168.38.1	1000.000 ms
39	192.168.39.1	1000.000 ms
40	192.168.40.1	1000.000 ms
41	192.168.41.1	1000.000 ms
42	192.168.42.1	1000.000 ms
43	192.168.43.1	1000.000 ms
44	192.168.44.1	1000.000 ms
45	192.168.45.1	1000.000 ms
46	192.168.46.1	1000.000 ms
47	192.168.47.1	1000.000 ms
48	192.168.48.1	1000.000 ms
49	192.168.49.1	1000.000 ms
50	192.168.50.1	1000.000 ms
51	192.168.51.1	1000.000 ms
52	192.168.52.1	1000.000 ms
53	192.168.53.1	1000.000 ms
54	192.168.54.1	1000.000 ms
55	192.168.55.1	1000.000 ms
56	192.168.56.1	1000.000 ms
57	192.168.57.1	1000.000 ms
58	192.168.58.1	1000.000 ms
59	192.168.59.1	1000.000 ms
60	192.168.60.1	1000.000 ms
61	192.168.61.1	1000.000 ms
62	192.168.62.1	1000.000 ms
63	192.168.63.1	1000.000 ms
64	192.168.64.1	1000.000 ms
65	192.168.65.1	1000.000 ms
66	192.168.66.1	1000.000 ms
67	192.168.67.1	1000.000 ms
68	192.168.68.1	1000.000 ms
69	192.168.69.1	1000.000 ms
70	192.168.70.1	1000.000 ms
71	192.168.71.1	1000.000 ms
72	192.168.72.1	1000.000 ms
73	192.168.73.1	1000.000 ms
74	192.168.74.1	1000.000 ms
75	192.168.75.1	1000.000 ms
76	192.168.76.1	1000.000 ms
77	192.168.77.1	1000.000 ms
78	192.168.78.1	1000.000 ms
79	192.168.79.1	1000.000 ms
80	192.168.80.1	1000.000 ms
81	192.168.81.1	1000.000 ms
82	192.168.82.1	1000.000 ms
83	192.168.83.1	1000.000 ms
84	192.168.84.1	1000.000 ms
85	192.168.85.1	1000.000 ms
86	192.168.86.1	1000.000 ms
87	192.168.87.1	1000.000 ms
88	192.168.88.1	1000.000 ms
89	192.168.89.1	1000.000 ms
90	192.168.90.1	1000.000 ms
91	192.168.91.1	1000.000 ms
92	192.168.92.1	1000.000 ms
93	192.168.93.1	1000.000 ms
94	192.168.94.1	1000.000 ms
95	192.168.95.1	1000.000 ms
96	192.168.96.1	1000.000 ms
97	192.168.97.1	1000.000 ms
98	192.168.98.1	1000.000 ms
99	192.168.99.1	1000.000 ms
100	192.168.100.1	1000.000 ms
101	192.168.101.1	1000.000 ms
102	192.168.102.1	1000.000 ms
103	192.168.103.1	1000.000 ms
104	192.168.104.1	1000.000 ms
105	192.168.105.1	1000.000 ms
106	192.168.106.1	1000.000 ms
107	192.168.107.1	1000.000 ms
108	192.168.108.1	1000.000 ms
109	192.168.109.1	1000.000 ms
110	192.168.110.1	1000.000 ms
111	192.168.111.1	1000.000 ms
112	192.168.112.1	1000.000 ms
113	192.168.113.1	1000.000 ms
114	192.168.114.1	1000.000 ms
115	192.168.115.1	1000.000 ms
116	192.168.116.1	1000.000 ms
117	192.168.117.1	1000.000 ms
118	192.168.118.1	1000.000 ms
119	192.168.119.1	1000.000 ms
120	192.168.120.1	1000.000 ms
121	192.168.121.1	1000.000 ms
122	192.168.122.1	1000.000 ms
123	192.168.123.1	1000.000 ms
124	192.168.124.1	1000.000 ms
125	192.168.125.1	1000.000 ms
126	192.168.126.1	1000.000 ms
127	192.168.127.1	1000.000 ms
128	192.168.128.1	1000.000 ms
129	192.168.129.1	1000.000 ms
130	192.168.130.1	1000.000 ms
131	192.168.131.1	1000.000 ms
132	192.168.132.1	1000.000 ms
133	192.168.133.1	1000.000 ms
134	192.168.134.1	1000.000 ms
135	192.168.135.1	1000.000 ms
136	192.168.136.1	1000.000 ms
137	192.168.137.1	1000.000 ms
138	192.168.138.1	1000.000 ms
139	192.168.139.1	1000.000 ms
140	192.168.140.1	1000.000 ms
141	192.168.141.1	1000.000 ms
142	192.168.142.1	1000.000 ms
143	192.168.143.1	1000.000 ms
144	192.168.144.1	1000.000 ms
145	192.168.145.1	1000.000 ms
146	192.168.146.1	1000.000 ms
147	192.168.147.1	1000.000 ms
148	192.168.148.1	1000.000 ms
149	192.168.149.1	1000.000 ms
150	192.168.150.1	1000.000 ms
151	192.168.151.1	1000.000 ms
152	192.168.152.1	1000.000 ms
153	192.168.153.1	1000.000 ms
154	192.168.154.1	1000.000 ms
155	192.168.155.1	1000.000 ms
156	192.168.156.1	1000.000 ms
157	192.168.157.1	1000.000 ms
158	192.168.158.1	1000.000 ms
159	192.168.159.1	1000.000 ms
160	192.168.160.1	1000.000 ms
161	192.168.161.1	1000.000 ms
162	192.168.162.1	1000.000 ms
163	192.168.163.1	1000.000 ms
164	192.168.164.1	1000.000 ms
165	192.168.165.1	1000.000 ms
166	192.168.166.1	1000.000 ms
167	192.168.167.1	1000.000 ms
168	192.168.168.1	1000.000 ms
169	192.168.169.1	1000.000 ms
170	192.168.170.1	1000.000 ms
171	192.168.171.1	1000.000 ms
172	192.168.172.1	1000.000 ms
173	192.168.173.1	1000.000 ms
174	192.168.174.1	1000.000 ms
175	192.168.175.1	1000.000 ms
176	192.168.176.1	1000.000 ms
177	192.168.177.1	1000.000 ms
178	192.168.178.1	1000.000 ms
179	192.168.179.1	1000.000 ms
180	192.168.180.1	1000.000 ms
181	192.168.181.1	1000.000 ms
182	192.168.182.1	1000.000 ms
183	192.168.183.1	1000.000 ms
184	192.168.184.1	1000.000 ms
185	192.168.185.1	1000.000 ms
186	192.168.186.1	1000.000 ms
187	192.168.187.1	1000.000 ms
188	192.168.188.1	1000.000 ms
189	192.168.189.1	1000.000 ms
190	192.168.190.1	1000.000 ms
191	192.168.191.1	1000.000 ms
192	192.168.192.1	1000.000 ms
193	192.168.193.1	1000.000 ms
194	192.168.194.1	1000.000 ms
195	192.168.195.1	1000.000 ms
196	192.168.196.1	1000.000 ms
197	192.168.197.1	1000.000 ms
198	192.168.198.1	1000.000 ms
199	192.168.199.1	1000.000 ms
200	192.168.200.1	1000.000 ms
201	192.168.201.1	1000.000 ms
202	192.168.202.1	1000.000 ms
203	192.168.203.1	1000.000 ms
204	192.168.204.1	1000.000 ms
205	192.168.205.1	1000.000 ms
206	192.168.206.1	1000.000 ms
207	192.168.207.1	1000.000 ms
208	192.168.208.1	1000.000 ms
209	192.168.209.1	1000.000 ms
210	192.168.210.1	1000.000 ms
211	192.168.211.1	1000.000 ms
212	192.168.212.1	1000.000 ms
213	192.168.213.1	1000.000 ms
214	192.168.214.1	1000.000 ms
215	192.168.215.1	1000.000 ms
216	192.168.216.1	1000.000 ms
217	192.168.217.1	1000.000 ms
218	192.168.218.1	1000.000 ms
219	192.168.219.1	1000.000 ms
220	192.168.220.1	1000.000 ms
221	192.168.221.1	1000.000 ms
222	192.168.222.1	1000.000 ms
223	192.168.223.1	1000.000 ms
224	192.168.224.1	1000.000 ms
225	192.168.225.1	1000.000 ms
226	192.168.226.1	1000.000 ms
227	192.168.227.1	1000.000 ms
228	192.168.228.1	1000.000 ms
229	192.168.229.1	1000.000 ms
230	192.168.230.1	1000.000 ms
231	192.168.231.1	1000.000 ms
232	192.168.232.1	1000.000 ms
233	192.168.233.1	1000.000 ms
234	192.168.234.1	1000.000 ms
235	192.168.235.1	1000.000 ms
236	192.168.236.1	1000.000 ms
237	192.168.237.1	1000.000 ms
238	192.168.238.1	1000.000 ms
239	192.168.239.1	1000.000 ms
240	192.168.240.1	1000.000 ms
241	192.168.241.1	1000.000 ms
242	192.168.242.1	1000.000 ms
243	192.168.243.1	1000.000 ms
244	192.168.244.1	1000.000 ms
245	192.168.245.1	1000.000 ms
246	192.168.246.1	1000.000 ms
247	192.168.247.1	1000.000 ms
248	192.168.248.1	1000.000 ms
249	192.168.249.1	1000.000 ms
250	192.168.250.1	1000.000 ms
251	192.168.251.1	1000.000 ms
252	192.168.252.1	1000.000 ms
253	192.168.253.1	1000.000 ms
254	192.168.254.1	1000.000 ms
stop reason: stop_completed
"
    when 1000:
        return "traceroute to 192.168.1000.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
13	192.168.13.1	1000.000 ms
14	192.168.14.1	1000.000 ms
15	192.168.15.1	1000.000 ms
16	192.168.16.1	1000.000 ms
17	192.168.17.1	1000.000 ms
18	192.168.18.1	1000.000 ms
19	192.168.19.1	1000.000 ms
20	192.168.20.1	1000.000 ms
21	192.168.21.1	1000.000 ms
22	192.168.22.1	1000.000 ms
23	192.168.23.1	1000.000 ms
24	192.168.24.1	1000.000 ms
25	192.168.25.1	1000.000 ms
26	192.168.26.1	1000.000 ms
27	192.168.27.1	1000.000 ms
28	192.168.28.1	1000.000 ms
29	192.168.29.1	1000.000 ms
30	192.168.30.1	1000.000 ms
31	192.168.31.1	1000.000 ms
32	192.168.32.1	1000.000 ms
33	192.168.33.1	1000.000 ms
34	192.168.34.1	1000.000 ms
35	192.168.35.1	1000.000 ms
36	192.168.36.1	1000.000 ms
37	192.168.37.1	1000.000 ms
38	192.168.38.1	1000.000 ms
39	192.168.39.1	1000.000 ms
40	192.168.40.1	1000.000 ms
41	192.168.41.1	1000.000 ms
42	192.168.42.1	1000.000 ms
43	192.168.43.1	1000.000 ms
44	192.168.44.1	1000.000 ms
45	192.168.45.1	1000.000 ms
46	192.168.46.1	1000.000 ms
47	192.168.47.1	1000.000 ms
48	192.168.48.1	1000.000 ms
49	192.168.49.1	1000.000 ms
50	192.168.50.1	1000.000 ms
51	192.168.51.1	1000.000 ms
52	192.168.52.1	1000.000 ms
53	192.168.53.1	1000.000 ms
54	192.168.54.1	1000.000 ms
55	192.168.55.1	1000.000 ms
56	192.168.56.1	1000.000 ms
57	192.168.57.1	1000.000 ms
58	192.168.58.1	1000.000 ms
59	192.168.59.1	1000.000 ms
60	192.168.60.1	1000.000 ms
61	192.168.61.1	1000.000 ms
62	192.168.62.1	1000.000 ms
63	192.168.63.1	1000.000 ms
64	192.168.64.1	1000.000 ms
65	192.168.65.1	1000.000 ms
66	192.168.66.1	1000.000 ms
67	192.168.67.1	1000.000 ms
68	192.168.68.1	1000.000 ms
69	192.168.69.1	1000.000 ms
70	192.168.70.1	1000.000 ms
71	192.168.71.1	1000.000 ms
72	192.168.72.1	1000.000 ms
73	192.168.73.1	1000.000 ms
74	192.168.74.1	1000.000 ms
75	192.168.75.1	1000.000 ms
76	192.168.76.1	1000.000 ms
77	192.168.77.1	1000.000 ms
78	192.168.78.1	1000.000 ms
79	192.168.79.1	1000.000 ms
80	192.168.80.1	1000.000 ms
81	192.168.81.1	1000.000 ms
82	192.168.82.1	1000.000 ms
83	192.168.83.1	1000.000 ms
84	192.168.84.1	1000.000 ms
85	192.168.85.1	1000.000 ms
86	192.168.86.1	1000.000 ms
87	192.168.87.1	1000.000 ms
88	192.168.88.1	1000.000 ms
89	192.168.89.1	1000.000 ms
90	192.168.90.1	1000.000 ms
91	192.168.91.1	1000.000 ms
92	192.168.92.1	1000.000 ms
93	192.168.93.1	1000.000 ms
94	192.168.94.1	1000.000 ms
95	192.168.95.1	1000.000 ms
96	192.168.96.1	1000.000 ms
97	192.168.97.1	1000.000 ms
98	192.168.98.1	1000.000 ms
99	192.168.99.1	1000.000 ms
100	192.168.100.1	1000.000 ms
101	192.168.101.1	1000.000 ms
102	192.168.102.1	1000.000 ms
103	192.168.103.1	1000.000 ms
104	192.168.104.1	1000.000 ms
105	192.168.105.1	1000.000 ms
106	192.168.106.1	1000.000 ms
107	192.168.107.1	1000.000 ms
108	192.168.108.1	1000.000 ms
109	192.168.109.1	1000.000 ms
110	192.168.110.1	1000.000 ms
111	192.168.111.1	1000.000 ms
112	192.168.112.1	1000.000 ms
113	192.168.113.1	1000.000 ms
114	192.168.114.1	1000.000 ms
115	192.168.115.1	1000.000 ms
116	192.168.116.1	1000.000 ms
117	192.168.117.1	1000.000 ms
118	192.168.118.1	1000.000 ms
119	192.168.119.1	1000.000 ms
120	192.168.120.1	1000.000 ms
121	192.168.121.1	1000.000 ms
122	192.168.122.1	1000.000 ms
123	192.168.123.1	1000.000 ms
124	192.168.124.1	1000.000 ms
125	192.168.125.1	1000.000 ms
126	192.168.126.1	1000.000 ms
127	192.168.127.1	1000.000 ms
128	192.168.128.1	1000.000 ms
129	192.168.129.1	1000.000 ms
130	192.168.130.1	1000.000 ms
131	192.168.131.1	1000.000 ms
132	192.168.132.1	1000.000 ms
133	192.168.133.1	1000.000 ms
134	192.168.134.1	1000.000 ms
135	192.168.135.1	1000.000 ms
136	192.168.136.1	1000.000 ms
137	192.168.137.1	1000.000 ms
138	192.168.138.1	1000.000 ms
139	192.168.139.1	1000.000 ms
140	192.168.140.1	1000.000 ms
141	192.168.141.1	1000.000 ms
142	192.168.142.1	1000.000 ms
143	192.168.143.1	1000.000 ms
144	192.168.144.1	1000.000 ms
145	192.168.145.1	1000.000 ms
146	192.168.146.1	1000.000 ms
147	192.168.147.1	1000.000 ms
148	192.168.148.1	1000.000 ms
149	192.168.149.1	1000.000 ms
150	192.168.150.1	1000.000 ms
151	192.168.151.1	1000.000 ms
152	192.168.152.1	1000.000 ms
153	192.168.153.1	1000.000 ms
154	192.168.154.1	1000.000 ms
155	192.168.155.1	1000.000 ms
156	192.168.156.1	1000.000 ms
157	192.168.157.1	1000.000 ms
158	192.168.158.1	1000.000 ms
159	192.168.159.1	1000.000 ms
160	192.168.160.1	1000.000 ms
161	192.168.161.1	1000.000 ms
162	192.168.162.1	1000.000 ms
163	192.168.163.1	1000.000 ms
164	192.168.164.1	1000.000 ms
165	192.168.165.1	1000.000 ms
166	192.168.166.1	1000.000 ms
167	192.168.167.1	1000.000 ms
168	192.168.168.1	1000.000 ms
169	192.168.169.1	1000.000 ms
170	192.168.170.1	1000.000 ms
171	192.168.171.1	1000.000 ms
172	192.168.172.1	1000.000 ms
173	192.168.173.1	1000.000 ms
174	192.168.174.1	1000.000 ms
175	192.168.175.1	1000.000 ms
176	192.168.176.1	1000.000 ms
177	192.168.177.1	1000.000 ms
178	192.168.178.1	1000.000 ms
179	192.168.179.1	1000.000 ms
180	192.168.180.1	1000.000 ms
181	192.168.181.1	1000.000 ms
182	192.168.182.1	1000.000 ms
183	192.168.183.1	1000.000 ms
184	192.168.184.1	1000.000 ms
185	192.168.185.1	1000.000 ms
186	192.168.186.1	1000.000 ms
187	192.168.187.1	1000.000 ms
188	192.168.188.1	1000.000 ms
189	192.168.189.1	1000.000 ms
190	192.168.190.1	1000.000 ms
191	192.168.191.1	1000.000 ms
192	192.168.192.1	1000.000 ms
193	192.168.193.1	1000.000 ms
194	192.168.194.1	1000.000 ms
195	192.168.195.1	1000.000 ms
196	192.168.196.1	1000.000 ms
197	192.168.197.1	1000.000 ms
198	192.168.198.1	1000.000 ms
199	192.168.199.1	1000.000 ms
200	192.168.200.1	1000.000 ms
201	192.168.201.1	1000.000 ms
202	192.168.202.1	1000.000 ms
203	192.168.203.1	1000.000 ms
204	192.168.204.1	1000.000 ms
205	192.168.205.1	1000.000 ms
206	192.168.206.1	1000.000 ms
207	192.168.207.1	1000.000 ms
208	192.168.208.1	1000.000 ms
209	192.168.209.1	1000.000 ms
210	192.168.210.1	1000.000 ms
211	192.168.211.1	1000.000 ms
212	192.168.212.1	1000.000 ms
213	192.168.213.1	1000.000 ms
214	192.168.214.1	1000.000 ms
215	192.168.215.1	1000.000 ms
216	192.168.216.1	1000.000 ms
217	192.168.217.1	1000.000 ms
218	192.168.218.1	1000.000 ms
219	192.168.219.1	1000.000 ms
220	192.168.220.1	1000.000 ms
221	192.168.221.1	1000.000 ms
222	192.168.222.1	1000.000 ms
223	192.168.223.1	1000.000 ms
224	192.168.224.1	1000.000 ms
225	192.168.225.1	1000.000 ms
226	192.168.226.1	1000.000 ms
227	192.168.227.1	1000.000 ms
228	192.168.228.1	1000.000 ms
229	192.168.229.1	1000.000 ms
230	192.168.230.1	1000.000 ms
231	192.168.231.1	1000.000 ms
232	192.168.232.1	1000.000 ms
233	192.168.233.1	1000.000 ms
234	192.168.234.1	1000.000 ms
235	192.168.235.1	1000.000 ms
236	192.168.236.1	1000.000 ms
237	192.168.237.1	1000.000 ms
238	192.168.238.1	1000.000 ms
239	192.168.239.1	1000.000 ms
240	192.168.240.1	1000.000 ms
241	192.168.241.1	1000.000 ms
242	192.168.242.1	1000.000 ms
243	192.168.243.1	1000.000 ms
244	192.168.244.1	1000.000 ms
245	192.168.245.1	1000.000 ms
246	192.168.246.1	1000.000 ms
247	192.168.247.1	1000.000 ms
248	192.168.248.1	1000.000 ms
249	192.168.249.1	1000.000 ms
250	192.168.250.1	1000.000 ms
251	192.168.251.1	1000.000 ms
252	192.168.252.1	1000.000 ms
253	192.168.253.1	1000.000 ms
254	192.168.254.1	1000.000 ms
255	192.168.255.1	1000.000 ms
stop reason: stop_hoplimit
"
    else nil
    end
  end
  
end #TraceTestTopologyPathLengthTest

class TraceTestTopologyMultipleResponsesTest

  def initialize
    @test_number = 1
  end

  def to_s
    "TraceTest Topology Multiple Responses Test"
  end

  def execute_all
    execute_method_tests(:icmp)
    execute_method_tests(:udp)
    execute_method_tests(:tcp)
  end

  def execute_method_tests(method)
    execute_test(method, :multiple_same_src)
    execute_test(method, :multiple_diff_src)
  end

  def execute_test(method, type)
    test_name = "#{self.to_s} (#{method}, #{type})"
    puts "Executing #{test_name}" if $options.verbose

    # 'work out' some of the features of our path
    path_length = 8 #rand(20) + 5
    multiple_resp_hop = path_length - 3
    multiple_resp_cnt = 100
    source = TraceTest.generate_ip(0,0)
    target = TraceTest.generate_ip(path_length,1)
    time = Time.now
    taskid = @test_number
    @test_number += 1
    reqnum = 1

    puts "Path Length: #{path_length}" if $options.verbose
    puts "Source: #{source}" if $options.verbose
    puts "Destination: #{target}" if $options.verbose

    $options.probe_method = method

    task = TraceTask.new(taskid, target, $options)

    while !task.is_complete && (probe = task.next_probe) != nil
      # create a response and pass it back to the task
      probe.id = reqnum
      #puts probe

      probe.result = result = TestResult.new(reqnum, source, probe.dest, 
                                            probe.ttl, time, probe.attempt)
      reqnum += 1
      time += 10
      
      result.responded = true
      result.reply_icmp = true

      result.reply_icmp_type = 11
      result.reply_icmp_code = 0

      if probe.ttl == path_length
        # match the address
        result.reply_src = target
        if method == :icmp
          result.reply_icmp_type = 0
          result.reply_icmp_code = 0
        else
          result.reply_icmp_type = 3
          result.reply_icmp_code = 3
        end
        task.receive_probe(probe)
      elsif probe.ttl == multiple_resp_hop
        multiple_resp_cnt.times do |i|
          probe.result = TestResult.new(reqnum, source, probe.dest, 
                                       probe.ttl, time, probe.attempt)
          probe.result.responded = true
          probe.result.reply_icmp = true
          
          probe.result.reply_icmp_type = 11
          probe.result.reply_icmp_code = 0
          if type == :multiple_diff_src
            probe.result.reply_src = TraceTest.generate_ip(probe.ttl, i+1)
          end
          task.receive_probe(probe)
        end
      else
        task.receive_probe(probe)
      end

    end

    puts task.result if $options.verbose
    
    if task.result.to_s == expected_result(method, type)
      puts "#{test_name} passed"
    else
      puts "#{test_name} failed"
      puts task.result
    end

  end

  def expected_result(method, type)
    if type == :multiple_diff_src
      return "traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
	192.168.5.2	1000.000 ms
	192.168.5.3	1000.000 ms
	192.168.5.4	1000.000 ms
	192.168.5.5	1000.000 ms
	192.168.5.6	1000.000 ms
	192.168.5.7	1000.000 ms
	192.168.5.8	1000.000 ms
	192.168.5.9	1000.000 ms
	192.168.5.10	1000.000 ms
	192.168.5.11	1000.000 ms
	192.168.5.12	1000.000 ms
	192.168.5.13	1000.000 ms
	192.168.5.14	1000.000 ms
	192.168.5.15	1000.000 ms
	192.168.5.16	1000.000 ms
	192.168.5.17	1000.000 ms
	192.168.5.18	1000.000 ms
	192.168.5.19	1000.000 ms
	192.168.5.20	1000.000 ms
	192.168.5.21	1000.000 ms
	192.168.5.22	1000.000 ms
	192.168.5.23	1000.000 ms
	192.168.5.24	1000.000 ms
	192.168.5.25	1000.000 ms
	192.168.5.26	1000.000 ms
	192.168.5.27	1000.000 ms
	192.168.5.28	1000.000 ms
	192.168.5.29	1000.000 ms
	192.168.5.30	1000.000 ms
	192.168.5.31	1000.000 ms
	192.168.5.32	1000.000 ms
	192.168.5.33	1000.000 ms
	192.168.5.34	1000.000 ms
	192.168.5.35	1000.000 ms
	192.168.5.36	1000.000 ms
	192.168.5.37	1000.000 ms
	192.168.5.38	1000.000 ms
	192.168.5.39	1000.000 ms
	192.168.5.40	1000.000 ms
	192.168.5.41	1000.000 ms
	192.168.5.42	1000.000 ms
	192.168.5.43	1000.000 ms
	192.168.5.44	1000.000 ms
	192.168.5.45	1000.000 ms
	192.168.5.46	1000.000 ms
	192.168.5.47	1000.000 ms
	192.168.5.48	1000.000 ms
	192.168.5.49	1000.000 ms
	192.168.5.50	1000.000 ms
	192.168.5.51	1000.000 ms
	192.168.5.52	1000.000 ms
	192.168.5.53	1000.000 ms
	192.168.5.54	1000.000 ms
	192.168.5.55	1000.000 ms
	192.168.5.56	1000.000 ms
	192.168.5.57	1000.000 ms
	192.168.5.58	1000.000 ms
	192.168.5.59	1000.000 ms
	192.168.5.60	1000.000 ms
	192.168.5.61	1000.000 ms
	192.168.5.62	1000.000 ms
	192.168.5.63	1000.000 ms
	192.168.5.64	1000.000 ms
	192.168.5.65	1000.000 ms
	192.168.5.66	1000.000 ms
	192.168.5.67	1000.000 ms
	192.168.5.68	1000.000 ms
	192.168.5.69	1000.000 ms
	192.168.5.70	1000.000 ms
	192.168.5.71	1000.000 ms
	192.168.5.72	1000.000 ms
	192.168.5.73	1000.000 ms
	192.168.5.74	1000.000 ms
	192.168.5.75	1000.000 ms
	192.168.5.76	1000.000 ms
	192.168.5.77	1000.000 ms
	192.168.5.78	1000.000 ms
	192.168.5.79	1000.000 ms
	192.168.5.80	1000.000 ms
	192.168.5.81	1000.000 ms
	192.168.5.82	1000.000 ms
	192.168.5.83	1000.000 ms
	192.168.5.84	1000.000 ms
	192.168.5.85	1000.000 ms
	192.168.5.86	1000.000 ms
	192.168.5.87	1000.000 ms
	192.168.5.88	1000.000 ms
	192.168.5.89	1000.000 ms
	192.168.5.90	1000.000 ms
	192.168.5.91	1000.000 ms
	192.168.5.92	1000.000 ms
	192.168.5.93	1000.000 ms
	192.168.5.94	1000.000 ms
	192.168.5.95	1000.000 ms
	192.168.5.96	1000.000 ms
	192.168.5.97	1000.000 ms
	192.168.5.98	1000.000 ms
	192.168.5.99	1000.000 ms
	192.168.5.100	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
stop reason: stop_completed
"
    elsif type == :multiple_same_src
      return "traceroute to 192.168.8.1
1	192.168.1.1	1000.000 ms
2	192.168.2.1	1000.000 ms
3	192.168.3.1	1000.000 ms
4	192.168.4.1	1000.000 ms
5	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
	192.168.5.1	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
stop reason: stop_completed
"
    else nil
    end
  end
  
end #TraceTestTopologyMultipleResponsesTest

class TraceTestLoopTestSet

  def initialize
    @tests = []
    @tests << TraceTestLoopTest.new
  end

  def execute_all
    @tests.each do |test|
      test.execute_all
    end
  end

  def to_s
    "TraceTest Topology Test Set"
  end

end #TraceTestTopologyTestSet

class TraceTestLoopTest

  def initialize
    @test_number = 1
  end

  def to_s
    "TraceTest Loop Test"
  end

  def execute_all
    execute_method_tests(:icmp)
    execute_method_tests(:udp)
    execute_method_tests(:tcp)
  end

  def execute_method_tests(method)
    execute_test(method, :general_loop_ABCA_disallow)
    execute_test(method, :general_loop_ABCA_allow)
    execute_test(method, :adjacent_loop_ABBC_disallow)
    execute_test(method, :adjacent_loop_ABBC_allow)
    execute_test(method, :adjacent_loop_ABBCZDDE_disallow)
    execute_test(method, :adjacent_loop_ABBCZDDE_allow)
    execute_test(method, :adjacent_loop_ABBCC__E_disallow)
    execute_test(method, :adjacent_loop_ABBCC__E_allow)
    execute_test(method, :adjacent_loop_mnlph_disallow)
    execute_test(method, :adjacent_loop_mnlph_allow)
    execute_test(method, :combo_loop_ABBCA_disallow)
    execute_test(method, :combo_loop_ABBCA_allow_adjacent)
    execute_test(method, :combo_loop_ABBCA_allow_both)
  end

  def execute_test(method, type)
    test_name = "#{self.to_s} (#{method}, #{type})"
    puts "Executing #{test_name}" if $options.verbose

    # 'work out' some of the features of our path
    path_length = 12 #rand(20) + 5
    loop_start = 2
    source = TraceTest.generate_ip(0,0)
    target = TraceTest.generate_ip(path_length,1)
    time = Time.now
    taskid = @test_number
    @test_number += 1
    reqnum = 1

    puts "Path Length: #{path_length}" if $options.verbose
    puts "Source: #{source}" if $options.verbose
    puts "Destination: #{target}" if $options.verbose

    $options.probe_method = method

    #reset to the defaults
    $options.loops = 1
    $options.loopaction = 0

    case type
    when :general_loop_ABCA_disallow:
        $options.loops = 1
      loop = ["A", "B", "C", "A"]
    when :general_loop_ABCA_allow:
        $options.loops = 0
      loop = ["A", "B", "C", "A"]
    when :adjacent_loop_ABBC_disallow:
        $options.loopaction = 0
      loop = ["A", "B", "B", "C"]
    when :adjacent_loop_ABBC_allow:
        $options.loopaction = 1
      loop = ["A", "B", "B", "C"]
    when :adjacent_loop_ABBCZDDE_disallow:
        $options.loopaction = 1
      loop = ["A", "B", "B", "C", "Z", "D", "D", "E"]
    when :adjacent_loop_ABBCZDDE_allow:
        $options.loopaction = 2
      loop = ["A", "B", "B", "C", "Z", "D", "D", "E"]
    when :adjacent_loop_ABBCC__E_disallow:
        $options.loopaction = 1
      loop = ["A", "B", "B", "C", "C", nil, nil, "E"]
    when :adjacent_loop_ABBCC__E_allow:
        $options.loopaction = 2
      loop = ["A", "B", "B", "C", "C", nil, nil, "E"]
    when :adjacent_loop_mnlph_disallow:
        $options.loopaction = 1
      loop_start = 1
      path_length = 21
      loop = ["202.90.149.65", "203.177.10.245", "120.28.0.149", "120.28.0.129",
              "120.28.0.10", "120.28.0.46", "120.29.217.29", "180.87.180.41", 
              "180.87.180.26", "180.87.12.54", "180.87.36.14", "116.0.79.34", 
              "59.163.16.121", "59.163.16.121", "172.31.55.222", 
              "172.31.55.222", nil, nil, nil, nil, nil, nil, nil, nil, nil, 
              nil, nil, nil, nil, nil, nil]
    when :adjacent_loop_mnlph_allow:
        $options.loopaction = 2
      loop_start = 1
      path_length = 21
      loop = ["202.90.149.65", "203.177.10.245", "120.28.0.149", "120.28.0.129",
              "120.28.0.10", "120.28.0.46", "120.29.217.29", "180.87.180.41", 
              "180.87.180.26", "180.87.12.54", "180.87.36.14", "116.0.79.34", 
              "59.163.16.121", "59.163.16.121", "172.31.55.222", 
              "172.31.55.222", nil, nil, nil, nil, nil, nil, nil, nil, nil, 
              nil, nil, nil, nil, nil, nil]
    when :combo_loop_ABBCA_disallow:
        $options.loops = 1
      $options.loopaction = 0
      loop = ["A", "B", "B", "C", "A"]
    when :combo_loop_ABBCA_allow_adjacent:
        $options.loops = 1
      $options.loopaction = 1
      loop = ["A", "B", "B", "C", "A"]
    when :combo_loop_ABBCA_allow_both:
        $options.loops = 0
      $options.loopaction = 1
      loop = ["A", "B", "B", "C", "A"]
    else raise "invalid type flag #{type}"
    end

    task = TraceTask.new(taskid, target, $options)

    while !task.is_complete && (probe = task.next_probe) != nil
      # create a response and pass it back to the task
      probe.id = reqnum
      #puts probe

      probe.result = result = TestResult.new(reqnum, source, probe.dest, 
                                            probe.ttl, time, probe.attempt)
      reqnum += 1
      time += 10
      
      result.responded = true
      result.reply_icmp = true
      result.reply_icmp_type = 11
      result.reply_icmp_code = 0

      if probe.ttl == path_length
        # match the address
        result.reply_src = target
        if method == :icmp
          result.reply_icmp_type = 0
          result.reply_icmp_code = 0
        else
          result.reply_icmp_type = 3
          result.reply_icmp_code = 3
        end
          
      elsif probe.ttl >= loop_start && loop.length > 0
        result.reply_src = loop.shift
        unless result.reply_src
          result.responded = false
        end
      end

      task.receive_probe(probe)

    end

    puts task.result if $options.verbose

    if task.result.to_s == expected_result(method, type)
      puts "#{test_name} passed"
    else
      puts "#{test_name} failed"
      puts task.result
    end

  end

  def expected_result(method, type)
    case type
    when :general_loop_ABCA_disallow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	C	1000.000 ms
5	A	1000.000 ms
stop reason: stop_loop
"
    when :general_loop_ABCA_allow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	C	1000.000 ms
5	A	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
stop reason: stop_completed
"
    when :adjacent_loop_ABBC_disallow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
stop reason: stop_loop
"
    when :adjacent_loop_ABBC_allow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
5	C	1000.000 ms
6	192.168.6.1	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
stop reason: stop_completed
"
    when :adjacent_loop_ABBCZDDE_disallow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
5	C	1000.000 ms
6	Z	1000.000 ms
7	D	1000.000 ms
8	D	1000.000 ms
stop reason: stop_loop
"
    when :adjacent_loop_ABBCZDDE_allow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
5	C	1000.000 ms
6	Z	1000.000 ms
7	D	1000.000 ms
8	D	1000.000 ms
9	E	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
stop reason: stop_completed
"
    when :combo_loop_ABBCA_disallow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
stop reason: stop_loop
"
    when :combo_loop_ABBCA_allow_adjacent:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
5	C	1000.000 ms
6	A	1000.000 ms
stop reason: stop_loop
"
    when :combo_loop_ABBCA_allow_both:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
5	C	1000.000 ms
6	A	1000.000 ms
7	192.168.7.1	1000.000 ms
8	192.168.8.1	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
stop reason: stop_completed
"
    when :adjacent_loop_ABBCC__E_disallow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
5	C	1000.000 ms
6	C	1000.000 ms
stop reason: stop_loop
"
    when :adjacent_loop_ABBCC__E_allow:
        return "traceroute to 192.168.12.1
1	192.168.1.1	1000.000 ms
2	A	1000.000 ms
3	B	1000.000 ms
4	B	1000.000 ms
5	C	1000.000 ms
6	C	1000.000 ms
7	*
	*
8	E	1000.000 ms
9	192.168.9.1	1000.000 ms
10	192.168.10.1	1000.000 ms
11	192.168.11.1	1000.000 ms
12	192.168.12.1	1000.000 ms
stop reason: stop_completed
"
    when :adjacent_loop_mnlph_disallow:
        return "traceroute to 192.168.12.1
1	202.90.149.65	1000.000 ms
2	203.177.10.245	1000.000 ms
3	120.28.0.149	1000.000 ms
4	120.28.0.129	1000.000 ms
5	120.28.0.10	1000.000 ms
6	120.28.0.46	1000.000 ms
7	120.29.217.29	1000.000 ms
8	180.87.180.41	1000.000 ms
9	180.87.180.26	1000.000 ms
10	180.87.12.54	1000.000 ms
11	180.87.36.14	1000.000 ms
12	116.0.79.34	1000.000 ms
13	59.163.16.121	1000.000 ms
14	59.163.16.121	1000.000 ms
15	172.31.55.222	1000.000 ms
16	172.31.55.222	1000.000 ms
stop reason: stop_loop
"
    when :adjacent_loop_mnlph_allow:
        return "traceroute to 192.168.12.1
1	202.90.149.65	1000.000 ms
2	203.177.10.245	1000.000 ms
3	120.28.0.149	1000.000 ms
4	120.28.0.129	1000.000 ms
5	120.28.0.10	1000.000 ms
6	120.28.0.46	1000.000 ms
7	120.29.217.29	1000.000 ms
8	180.87.180.41	1000.000 ms
9	180.87.180.26	1000.000 ms
10	180.87.12.54	1000.000 ms
11	180.87.36.14	1000.000 ms
12	116.0.79.34	1000.000 ms
13	59.163.16.121	1000.000 ms
14	59.163.16.121	1000.000 ms
15	172.31.55.222	1000.000 ms
16	172.31.55.222	1000.000 ms
17	*
	*
18	*
	*
19	*
	*
20	*
	*
21	192.168.12.1	1000.000 ms
stop reason: stop_completed
"
    else raise "invalid type flag #{type}"
    end

  end
  
end #TraceTestLoopTest

#==============================================================================
# TestResult
# 
# TestResult is a re-creation of PingResult which allows PingResult objects
# to be forged by the TraceTestTest classes for returning to TraceTask
#==============================================================================
class TestResult
  attr_accessor :reqnum
  attr_accessor :probe_src, :probe_dest, :udata
  attr_accessor :tx_sec, :tx_usec, :rx_sec, :rx_usec
  attr_accessor :probe_ttl, :probe_ipid, :reply_src, :reply_ttl, :reply_qttl
  attr_accessor :reply_rr
  attr_accessor :reply_tsps_ts1, :reply_tsps_ip1
  attr_accessor :reply_tsps_ts2, :reply_tsps_ip2
  attr_accessor :reply_tsps_ts3, :reply_tsps_ip3
  attr_accessor :reply_tsps_ts4, :reply_tsps_ip4
  attr_accessor :reply_ipid

  attr_accessor :responded
  attr_accessor :reply_icmp_type, :reply_icmp_code, :reply_icmp
  attr_accessor :reply_tcp

  @@ipid = 0

  def initialize(reqnum, src, dest, ttl, time, attempt)
    self.reqnum = reqnum
    self.probe_src = src
    self.probe_dest = dest

    self.tx_sec = time.to_i
    self.tx_usec = 0
    time += 1
    self.rx_sec = time.to_i
    self.rx_usec = 0

    self.probe_ttl = ttl
    self.reply_src = TraceTest.generate_ip(ttl, attempt)
    self.reply_ttl = rand(255)
    self.reply_qttl = ttl

    self.reply_ipid = @@ipid
    @@ipid += 1
  end
  
  def responded?
    @responded
  end
  
  def icmp_reply?
    @reply_icmp != nil
  end
  
  def tcp_reply?
    @reply_tcp != nil
  end
  
  #def reply_icmp_type
  #  @reply_icmp ? @reply_icmp >> 8 : nil
  #end
  
  #def reply_icmp_code
  #  @reply_icmp ? @reply_icmp & 0xff : nil
  #end
  
  def reply_tcp_flags
    @reply_tcp
  end
  
  # Just a convenience function.  This returns the same strings as warts-dump.
  def decompose_tcp_flags
    return nil unless @reply_tcp
    retval = []
    retval << "fin" if (@reply_tcp & 0x01) != 0
    retval << "syn" if (@reply_tcp & 0x02) != 0
    retval << "rst" if (@reply_tcp & 0x04) != 0
    retval << "psh" if (@reply_tcp & 0x08) != 0
    retval << "ack" if (@reply_tcp & 0x10) != 0
    retval << "urg" if (@reply_tcp & 0x20) != 0
    retval << "ece" if (@reply_tcp & 0x40) != 0
    retval << "cwr" if (@reply_tcp & 0x80) != 0
    retval
  end
end #TestResult


################################################################################
################################################################################
# Traceroute library classes
# 
# The following three classes - TraceResult, Hop and TraceTask should
# eventually be moved to a stand-alone library which can be used as
# a high-level traceroute method.
#
# Users of the library would instantiate a TraceTask class 
#
################################################################################
################################################################################

#==============================================================================
# TraceResult
# 
# A TraceResult object encapsulates the results of a traceroute to a given
# destination address.
# It is initialized with the target (destination) address of the trace and
# the firsthop TTL value with which to initialize the hop array.
# Once tracing is complete, it contains an array of Hop objects which
# themselves contain the responses to the trace probes.
# 
# The hops array is indexed by TTL value, and as such can contain empty (nil)
# elements. The first valid element in the array should be at the firsthop
# ttl and the last will usually be at the TTL of the destination, or the TTL
# of the last hop probed before giving up due to the gaplimit being reached.
# When the lastditch gapaction is used however, there can be a large gap in the
# hops array, with the last element being the responses to the lastditch
# probes at TTL 255
#==============================================================================
class TraceResult
  
  attr_reader :target
  attr_accessor :hops, :stop_reason  
  def initialize(target, firsthop)
    @target = target
    @hops = [] # hash of hops TTL => hop
    allocate_hop(firsthop)
  end

  def allocate_hop(ttl)
    hop = Hop.new(ttl)
    @hops[ttl-1] = hop
    return hop
  end

  def hop_at_ttl(ttl)
    return @hops[ttl-1]
  end

  def to_s
    str = "traceroute to #{@target}\n"
    @hops.each do |hop|
      next unless hop && hop.results.length != 0
      str += hop.to_s
    end
    str += "stop reason: #{@stop_reason}\n"
  end 

  def scamper_to_s
    str = "traceroute to #{@target}\n"
    @hops.each do |hop|
      next unless hop && hop.results.length != 0
      str += hop.scamper_to_s
    end
    str += "stop reason: #{@stop_reason}\n"
  end

end

#==============================================================================
# Hop
#
# A Hop object is a lightweight wrapper around an array of PingResult objects
# which are the responses to probes at the given TTL.
# It also has a to_s method which allows the trace to be printed in an ASCII
# format which is similar to that used by scamper and bin traceroute. It is
# slightly more verbose in that it explicitly prints the address of each
# response on a separate line.
#==============================================================================
class Hop

  attr_accessor :ttl, :results, :responsive

  def initialize(ttl)
    @ttl = ttl
    @results = []
    @responsive = true
  end

  def to_s
    str = @ttl.to_s
    str += "\n" if @results.length == 0

    @results.each do |result|
      if result.responded?
        str += sprintf("\t%s\t\%.3f ms", result.reply_src, rtt(result))
        if $options.full
          if $options.tsps
            str += sprintf("\t%s", build_tsps_str(result))
          elsif $options.rr
            str += sprintf("\t%s", result.reply_rr)
          end
        end
        str += "\n"
      else
        str += sprintf("\t*\n")
      end
    end
    return str
  end

  def scamper_to_s
    str = @ttl.to_s
    str += "\n" if @results.length == 0
    
    no_responses = true

    sorted = @results.sort {|x, y| x.probe_ipid <=> y.probe_ipid}

    sorted.each do |result|
      if result.responded?
        no_responses = false
        str += sprintf("\t%s\t\%.3f ms\n", result.reply_src, rtt(result))
      end
    end

    if no_responses
      str += sprintf("\t*\n")
    end
    return str
  end

  def build_tsps_str(result)
    str = ""
    str += sprintf("%s=%d", result.reply_tsps_ip1, result.reply_tsps_ts1) if 
      result.reply_tsps_ip1
    str += sprintf("%s=%d", result.reply_tsps_ip2, result.reply_tsps_ts2) if 
      result.reply_tsps_ip2
    str += sprintf("%s=%d", result.reply_tsps_ip3, result.reply_tsps_ts3) if 
      result.reply_tsps_ip3
    str += sprintf("%s=%d", result.reply_tsps_ip4, result.reply_tsps_ts4) if 
      result.reply_tsps_ip4
    return str
  end

  def rtt(result)
    return "-" if !result.responded?
    tx = Time.at(result.tx_sec, result.tx_usec)
    rx = Time.at(result.rx_sec, result.rx_usec)
    (rx-tx) * 1000
  end
  
end

#==============================================================================
# Probe
# 
# A Probe object is used as the primary form of communication between the
# TraceTask and the TraceManager (or other tracing logic). It is constructed
# by the TraceTask object in response to a call to the TraceTask#next_probe
# method.
# The Probe object is constructed with a destination IP address, a TTL and
# an attempt value. Once the TraceTask#next_probe method returns a Probe
# instance, the TraceManager inserts an internal id field (which in this
# implementation is a reqnum counter maintained in the TraceManager object) 
# allowing it to match probes and responses. It also inserts a reference to 
# the TraceTask object which crafted the probe.
#
# Once a reponse is received by the TraceManager, it inserts the PingResult
# object into the appropriate Probe object and passes it back to the TraceTask
# by calling TraceTask#receive_probe
#
#==============================================================================
class Probe

  attr_accessor :id, :task, :dest, :ttl, :attempt, :result
  
  def initialize(dest, ttl, attempt)
    self.dest = dest
    self.ttl = ttl
    self.attempt = attempt #internal id for the task to use
  end

  def to_s
    "Probe #{id}: #{dest} TTL: #{ttl}"
  end
    
end

class TraceTask

  attr_reader :taskid, :is_complete

  def initialize(taskid, target, options)
    @options = options
    @taskid = taskid
    @target = target

    #log("#{@target}: trace starting at #{Time.now}");

    @trace_result = TraceResult.new(@target, @options.firsthop)
    @is_complete = false

    @ttl        = @options.firsthop

    @attempt    = 0
    @n          = 2 # used for confidence, assume two initially
    # @loopc      = 0
    @iloopc     = 0

    @replies = []
    #@probe_queue = []
    @outstanding_probe = false
    
    @interfaces = []

    @state = :trace

    @first = true
  end
  
  def to_s
    "Task: #{@taskid} To: #{@target} TTL: #{@ttl}"
  end

  def next_probe
    # what is our next probe?
    return nil if @is_complete || @outstanding_probe
    @outstanding_probe = true
    @attempt += 1
    return Probe.new(@target, @ttl, @attempt)
  end

  def receive_probe(probe)
    unless probe
      return
    end

    @outstanding_probe = false

    if @state == :trace
      if !probe.result.responded?
        receive_timeout_probe(probe)
      elsif probe.result.icmp_reply?
        receive_icmp_probe(probe)
      elsif probe.result.tcp_reply?
        receive_tcp_probe(probe)
      else
        $stderr.puts "FATAL ERROR: unknown reply type"
      end
    elsif @state == :lastditch
      if !probe.result.responded?
        receive_lastditch_timeout_probe(probe)
      else
        receive_lastditch_probe(probe)
      end
    end
  end

  def is_complete
    #if @is_complete
      #puts @trace_result #don't force users to have the trace dumped to stdout
      #log("#{@target}: trace complete at #{Time.now}")
    #end
    return @is_complete
  end

  def result
    return @trace_result
  end

  ############################################################################
  # All methods below this point are internal to the TraceTask object
  # Users should not need to ever directly call them
  ############################################################################
  private

  def add_interface(interface)
    unless @interfaces.include?(interface)
      @interfaces << interface
      @n = @interfaces.length + 1
    end
  end

  def receive_icmp_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result
    hop.responsive = true

    return if @is_complete # no point checking any more

    # to make the port from scamper easier, we assume that we're not
    # going to probe any more as the default position of this method
    @is_complete = true

    # if this reply is not for the current ttl (i.e. a late reply),
    # check if we can stop now
    if(result.probe_ttl != @ttl)
      reason = stop_reason(result)
      if(reason != :stop_none)
        @trace_result.stop_reason = reason
      else
        @is_complete = false
      end
      return
    end

    ##
    # the rest of the code in this function deals with the fact this is a
    # reply for the current working hop.
    #
    # check if we are to send all allotted probes to the target
    ##
    if(@options.all_allocated)
      if(@options.confidence)
        $stderr.puts "FATAL ERROR: confidence and all_allocated cannot be "\
          "used simulaneously"
      end
      
      ##
      # if we get an out of order reply, then we go back to waiting for
      # the one we just probed for
      ##
      if(probe.attempt != @attempt)
        @is_complete = false
        return
      end

      ##
      # this response is for the last probe sent.  if there are still
      # probes to send for this hop, then send the next one
      ##
      if(@attempt < @options.attempts)
        @is_complete = false
        return
      end

    elsif(@options.confidence)
      ##
      # record details of the interface, if its details are not
      # currently held
      ##
      add_interface(result.reply_src)

      if(@n <= CONFIDENCE_MAX_N)
        ##
        # if we get an out of order reply, then we go back to waiting for
        # the one we just probed for
        ##
        if(probe.attempt != @attempt)
          @is_complete = false
          return
        end

        ##
        # this response is for the last probe sent.  if there are still
        # probes to send for this hop, then send the next one
        ##
        if(@attempt < k(@n))
          @is_complete = false
          return
        end
      end

      ##
      # if we get to here, the confidence for this hop is done,
      # reset the state we keep about that stuff
      ##
      @n = 2
      @interfaces = []
    end

    ##
    # if we're in a mode where we only care about the first response to
    # a probe, then check it now.  the else block below handles the case
    # where we want a larger number of responses from a hop.
    ##
    if(!@options.confidence && !@options.all_allocated)
      #check to see if we have a stop reason from the ICMP response
      reason = stop_reason(result)
      if(reason != :stop_none)
        @trace_result.stop_reason = reason
        return
      end
    else
      # check all hop records for a reason to halt the trace
      # @trace_result.hops.each do |hop|
        #next unless hop
      checked = []
      hop.results.each do |tr|
        # there is no point checking if we have already checked this interface
        next if checked.include? tr.reply_src
        checked << tr.reply_src
        reason = stop_reason(tr)
        if(reason != :stop_none)
          @trace_result.stop_reason = reason
          return
        end
      end
      # end
    end
    
    # check if we've reached the hoplimit
    if(@trace_result.hops.length == 255 || 
       @trace_result.hops.length == @options.hoplimit)
      @trace_result.stop_reason = :stop_hoplimit
      return
    end

    #move on to the next ttl

    @attempt = 0
    @ttl += 1
    @trace_result.allocate_hop(@ttl)
    
    @is_complete = false
    return
    
  end

  def receive_tcp_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result
    hop.responsive = true

    return if @is_complete # no point checking any more

    # to make the port from scamper easier, we assume that we're not
    # going to probe any more as the default position of this method
    @is_complete = true

    # if we are sending all allotted probes to the target
    if(@options.all_attempts)
      if(probe.attempts != @attempt)
        @is_complete = false
        return
      end
    elsif(@options.confidence)
      # record details of the interface
      add_interface(result.reply_src)

      if(@n <= CONFIDENCE_MAX_N && @attempt < k(@n))
        @is_completed = false
        return
      end
    end

    @trace_result.stop_reason = :stop_completed
    return
  end

  def receive_lastditch_probe(probe)
    result = probe.result
    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result
    hop.responsive = true

    return if @is_complete # no point checking any more

    # we received a reply from the destination, be done.

    @is_complete = true
    @trace_result.stop_reason = :stop_gaplimit
    return
  end

  def receive_timeout_probe(probe)
    result = probe.result

    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result

    return if @is_complete # no point checking any more

    if(@attempt == @options.attempts)
      @is_complete = true
      hop.responsive = false
      # all probes for this hop have now been sent

      # scamper does a check to see if any of the other responses can be
      # used for a stop reason. this shouldnt apply for us, but let's do
      # it anyway.
      #@trace_result.hops.each do |hop|
      #  next unless hop
      #  checked = []
      #  hop.results.each do |tr|
      #    next if checked.include? tr.reply_src
      #    checked << tr.reply_src
      #    reason = stop_reason(tr)
      #    if(reason != :stop_none)
      #      puts "found a stop reason from the non response: #{reason}"
      #      @trace_result.stop_reason = reason
      #      return
      #    end
      #  end
      #end
      
      # check if we've reached the hoplimit
      if(@trace_result.hops.length == 255 || 
         @trace_result.hops.length == @options.hoplimit)
        @trace_result.stop_reason = :stop_hoplimit
        return
      end

      # see if a non-response for this hop brings us to the gap limit
      if(@trace_result.hops.length >= @options.gaplimit)
        # start at the current ttl -1 and go back gaplimit -1 hops
        # check if all of these hops are unresponsive
        deadpath = true
        (@ttl-1).downto(@ttl-(@options.gaplimit-1)) do |i|
          hop = @trace_result.hop_at_ttl(i)
          if hop && hop.responsive
            deadpath = false
            break
          end
        end

        # add lastditch mode stuff in here
        if deadpath
          if @options.gapaction == :stop
            @trace_result.stop_reason = :stop_gaplimit
          elsif @options.gapaction == :lastditch
            @is_complete = false
            @state = :lastditch
            @attempt = 0
            @ttl = 255
            @trace_result.allocate_hop(@ttl)
          else
            $stderr.puts "FATAL ERROR: invalid gapaction: @options.gapaction"
          end
          return
        end

      end
      @attempt = 0
      @ttl += 1
      @trace_result.allocate_hop(@ttl)
      @is_complete = false
    end
  end

  def receive_lastditch_timeout_probe(probe)
    result = probe.result

    hop = @trace_result.hop_at_ttl(result.probe_ttl)

    unless hop
      $stderr.puts "FATAL ERROR: no hop record for #{result.probe_ttl}"
      exit -1
    end

    hop.results << result
    
    if(@attempt == @options.attempts)
      # this is the last lastditch probe, give up!
      @is_complete = true
      @trace_result.stop_reason = :stop_gaplimit
      return
    end
  end


  ###
  # decide if this result is a good enough reason to stop
  def stop_reason(result)
    
    ##
    # the message received is an ICMP port unreachable -- something that
    # the destination should have sent.  make sure the port unreachable
    # message makes sense based on the traceroute type.
    ##
  
    if(is_icmp_unreach_port(result) && (is_trace_method(:udp) || 
                                        is_trace_method(:tcp)))
      reason = :stop_completed
    elsif(is_icmp_unreach(result))
      reason = :stop_unreach
    elsif(is_icmp_echo_reply(result))
      ##
      # the message received is an ICMP echo reply -- something that only
      # makes sense to include as part of the traceroute if the traceroute
      # is using echo requests.
      ##
      if(is_trace_method(:icmp))
        reason = :stop_completed
      else
        raise "ICMP Echo Reply response received for a UDP or TCP probe "\
          "to #{result.reply_src}"
        reason = :stop_none
      end
    elsif(@options.loops != 0 && is_loop(result)) 
      # checked for and found loop condition
      reason = :stop_loop
    elsif(is_icmp_ttl_exp(result) && @options.not_time_exceeded == false &&
          is_target(result))
      ##
      # if an ICMP TTL expired message is received from an IP address
      # matching the destination being probed, and the traceroute is
      # to stop when this occurs, then stop.
      ##
      reason = :stop_completed
    elsif(is_trace_method(:tcp) && is_method(:tcp, result))
      reason = :stop_completed
    else
      reason = :stop_none
    end

    return reason
  end
  
  def is_trace_method(method)
    return @options.probe_method == method
  end

  def is_method(method, result)
    case method
    when :icmp:
        return result.icmp_reply?
    when :tcp:
        return result.tcp_reply?
    end
  end
  
  def is_icmp_ttl_exp(result)
    (!is_method(:tcp, result) || result.reply_icmp_type == 11)
  end
  
  def is_icmp_ttl_exp_trans(result)
    (!is_method(:tcp, result) && 
     result.reply_icmp_type == 11 && result.reply_icmp_code == 0)
  end
  
  def is_icmp_unreach(result)
    (!is_method(:tcp, result) && result.reply_icmp_type == 3)
  end

  def is_icmp_unreach_port(result)
    (!is_method(:tcp, result) &&
     result.reply_icmp_type == 3 && result.reply_icmp_code == 3)
  end
  
  def is_icmp_echo_reply(result)
    (!is_method(:tcp, result) && result.reply_icmp_type == 0)
  end
  
  def is_target(result)
    (@target == result.reply_src)
  end
  
  def is_loop(result)

    # need at least a couple of probes first
    if(result.probe_ttl <= @options.firsthop)
      return false
    end

    one_adjacent = false

    # compare all hop records until the hop prior to this one
    (result.probe_ttl-1).downto(@options.firsthop) do |i|

      checked_interfaces = []

      # all the results for the hop
      @trace_result.hop_at_ttl(i).results.each do |res|

        next unless res.responded?

        # only check an address once per hop
        next if checked_interfaces.include? res.reply_src

        checked_interfaces << res.reply_src
        # if the addresses match, then there is a loop
        if(res.reply_src == result.reply_src)

          # if the loop is between adjacent hops
          if(res.probe_ttl + 1 == result.probe_ttl)
            
            ##
            # check for zero-ttl forwarding.  continue probing if
            # the condition is met.
            ##
            if(res.reply_qttl == 0 && result.reply_qttl == 1)
              return false
            end
            
            # mark these as adjacent so that if the next interface
            # is also repeated we can mark that as a loop, otherwise,
            # mark this as an adjacent loop
            one_adjacent = true

            # move on to the next hop 
            # (i.e. ignore any other results at this hop)
            break

          elsif(res.probe_ttl + 2 == result.probe_ttl && one_adjacent)

            # this loop has one interface in the middle: AXA
            # and we saw AA at the last hop, so we can infer AAA
            return true

          end # we're looking at identical addresses but not at adjacent hops

          # these interfaces are not adjacent
          one_adjacent = false
          
          # check if the loop condition is met
          #@loopc += 1
          #if(@loopc >= @options.loops)
          #  return true
          #end
          
          #this assumes that @options.loops == 1
          # if it is set to 0, this is checked earlier.
          # setting loops to > 1 is silly and is not allowed
          # by the arg parse.
          # if you want the check for the number of 'loops' back,
          # then comment the following line and uncommend the four
          # lines above plus the break below
          return true

          # break
        elsif(one_adjacent)
          # this address is not the same as the test address, but
          # we previously saw AA, so assume we are at AAX and increment
          # the count of adjacent interface loops
          if(@iloopc < @options.loopaction)
            @iloopc += 1
            one_adjacent = false
            break # look for other loops
          else 
            return true
          end
        end # addresses are not the same, nor is one_adjacent set

      end # result loop

    end # hop loop

    # got all the way back to the start of the path with no loop
    return false
    
  end

  @@k = [
         [   0,   0 ], [   0,   0 ], [   6,   8 ], [  11,  15 ], [  16,  21 ],
         [  21,  28 ], [  27,  36 ], [  33,  43 ], [  38,  51 ], [  44,  58 ],
         [  51,  66 ], [  57,  74 ], [  63,  82 ], [  70,  90 ], [  76,  98 ],
         [  83, 106 ], [  90, 115 ], [  96, 123 ], [ 103, 132 ], [ 110, 140 ],
         [ 117, 149 ], [ 124, 157 ], [ 131, 166 ], [ 138, 175 ], [ 145, 183 ],
         [ 152, 192 ], [ 159, 201 ], [ 167, 210 ], [ 174, 219 ], [ 181, 228 ],
         [ 189, 237 ], [ 196, 246 ], [ 203, 255 ], [ 211, 264 ], [ 218, 273 ],
         [ 226, 282 ], [ 233, 291 ], [ 241, 300 ], [ 248, 309 ], [ 256, 319 ],
         [ 264, 328 ], [ 271, 337 ], [ 279, 347 ], [ 287, 356 ], [ 294, 365 ],
         [ 302, 375 ], [ 310, 384 ], [ 318, 393 ], [ 326, 403 ], [ 333, 412 ],
         [ 341, 422 ], [ 349, 431 ], [ 357, 441 ], [ 365, 450 ], [ 373, 460 ],
         [ 381, 470 ], [ 389, 479 ], [ 397, 489 ], [ 405, 499 ], [ 413, 508 ],
         [ 421, 518 ], [ 429, 528 ], [ 437, 537 ], [ 445, 547 ], [ 453, 557 ],
         [ 462, 566 ], [ 470, 576 ], [ 478, 586 ], [ 486, 596 ], [ 494, 606 ],
         [ 502, 616 ], [ 511, 625 ], [ 519, 635 ], [ 527, 645 ], [ 535, 655 ],
         [ 544, 665 ], [ 552, 675 ], [ 560, 685 ], [ 569, 695 ], [ 577, 705 ],
         [ 585, 715 ], [ 594, 725 ], [ 602, 735 ], [ 610, 745 ], [ 619, 755 ],
         [ 627, 765 ], [ 635, 775 ], [ 644, 785 ], [ 652, 795 ], [ 661, 805 ],
         [ 669, 815 ], [ 678, 825 ], [ 686, 835 ], [ 695, 845 ], [ 703, 855 ],
         [ 712, 866 ], [ 720, 876 ], [ 729, 886 ], [ 737, 896 ], [ 746, 906 ],
        ]
  
  CONFIDENCE_MAX_N = @@k.length
  
  def k(n)
    return @@k[n][@options.confidence]
  end
  
  def log(message)
    $stderr.puts message if @options.verbose
  end
  
end #TraceTask

################################################################################

if $options.wartsfile
  simulator = TraceSim.new
  simulator.start
elsif $options.test
  tester = TraceTest.new
  tester.start
else
  traceManager = TraceManager.new
  traceManager.start
end
